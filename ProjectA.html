<body>
<canvas id="glcanvas" width="1024" height="768">
</canvas>

<script src="lib/webgl-utils.js"></script>
<script src="lib/webgl-debug.js"></script>
<script src="lib/cuon-utils.js"></script>
<script src="lib/cuon-matrix-quat.js"></script> 


<script id="fragmentShader" type="x-shader/x-fragment">
precision mediump float;

varying vec4 vColor;

void main(void) {
	gl_FragColor = vec4(1.0,1.0,1.0,1.0);
}
</script>

<script id="vertexShader" type="x-shader/x-vertex">
attribute vec3 a_Position;

uniform mat4 uViewMatrix;
uniform mat4 uProjMatrix;

varying vec4 vColor;

void main(void) {
	gl_Position = uProjMatrix * uViewMatrix * vec4(a_Position, 1.0);
	gl_PointSize = 10.0;
	vColor = vec4(1.0,1.0,1.0,1.0);
}
</script>


<script type="text/javascript">

//globals
var gl //context
var a_PositionID 
var a_ColorID 
var canvas //canvas element

var Renderer = function(){
	 var Camera = function(){
		//look down the z negative axis
		this.eyeX = 0
		this.eyeY = 0.5
		this.eyeZ = 0
		this.atX = 0
		this.atY = 0
		this.atZ = -1
		this.upX = 0
		this.upY = 1
		this.upZ = 0
		this.fovy  = 70
		this.aspect  = 1.0
		this.near = .01
		this.far  = 100
		
		this.pan = 0
		this.tilt = 0
		this.roll = 0
		
		this.transX = 0
		this.transY = 0
		this.transZ = 0
		
		this.projectionMatrix = function(){
			return new Matrix4().setPerspective(this.fovy, this.aspect, this.near, this.far)
		}
		this.viewMatrix = function(){
			var vm =  new Matrix4().setLookAt(this.eyeX, this.eyeY, this.eyeZ, this.atX, this.atY, this.atZ, this.upX, this.upY, this.upZ)
			var vmrotated = vm.rotate(this.pan,0,1,0).rotate(this.tilt,1,0,0).rotate(this.roll,0,0,1)
			return vmrotated.translate(this.transX,this.transY,this.transZ)
		}
		
		this.keyboardControl = function(ev){
			var speed = 2
			switch(ev.keyCode) {
				case 39://right arrow
					this.pan += speed;break
				case 37://left arrow
					this.pan -= speed;break
				case 38://up arrow
					this.tilt += speed;break
				case 40://down arrow
					this.tilt -= speed;break
				case 65://a
					this.transX += speed/40;break
				case 90://z
					this.transX -= speed/40;break
				case 83://s           
					this.transY += speed/40;break
				case 88://x           
					this.transY -= speed/40;break
				case 68://d           
					this.transZ += speed/40;break
				case 67://c           
					this.transZ -= speed/40;break
				case 70://f
					this.roll += speed;break
				case 86://v
					this.roll -= speed;break
			}
		
		}
		
	}
	this.cam0 = new Camera()
	this.uViewMatrixID
	this.uProjMatrixID 
	this.partSys
	this.ground_plane
	this.start = function(){
	
		//gl setup
		canvas = document.getElementById("glcanvas")
		gl = WebGLUtils.setupWebGL(canvas)

		gl.viewport(0,0,1024,768)
		gl.clearColor(0.0, 0.0, 0.0, 1.0)                     
		gl.enable(gl.DEPTH_TEST)                              
		gl.depthFunc(gl.LEQUAL)  

		//compile shaders
		var fragmentShader = utils.getShader(gl, "fragmentShader");
		var vertexShader = utils.getShader(gl, "vertexShader");
		
		// Create the shader program
		shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);

		// If creating the shader program failed, alert

		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			alert("Unable to initialize the shader program.");
		}

		gl.useProgram(shaderProgram);
		
		//position attribute
		a_PositionID = gl.getAttribLocation(shaderProgram, 'a_Position')
		if(a_PositionID < 0) console.log('Failed to get the gfx storage location of a_Position')
		gl.enableVertexAttribArray(a_PositionID);
		
		
		//projection matrix location
		uProjMatrixID = gl.getUniformLocation(shaderProgram, 'uProjMatrix')
		if(uProjMatrixID < 0) console.log('Failed to get the gfx storage location of uProjMatrix')
		
		//view matrix location
		uViewMatrixID = gl.getUniformLocation(shaderProgram, 'uViewMatrix')
		if(uViewMatrixID < 0) console.log('Failed to get the gfx storage location of uViewMatrix')
		
		//groundplane
		this.ground_plane = new GroundPlane(gl,"Y", 60, .2)
		this.ground_plane.init()
		
		//particle system
		this.partSys = new ParticleSystem(gl)
		this.partSys.initBuffers()
		
		//keyboard control
		window.addEventListener("keydown", this.cam0.keyboardControl.bind(this.cam0), false);
		
		//mouse control
		window.addEventListener("mousedown", this.partSys.shootParticleMouseHandler.bind(this.partSys), false);
		
		//add gravity
		this.partSys.addGravity()
		
		window.requestAnimationFrame(this.draw.bind(this));
		
	}
	this.draw = function(){
		gl.clear(gl.COLOR_BUFFER_BIT)
		
		//set camera placement
		gl.uniformMatrix4fv(uProjMatrixID, false, this.cam0.projectionMatrix().elements)
		gl.uniformMatrix4fv(uViewMatrixID, false, this.cam0.viewMatrix().elements)
		
		this.ground_plane.draw()
		this.partSys.draw()
		
		window.requestAnimationFrame(this.draw.bind(this));
	}

}


//A ground plane is "renderable", meaning it takes gl context as input and provides a draw function
//axis == "X" "Y" or "Z" meaning x==0 y==0 or z==0
var GroundPlane = function(glContext, axis, num_lines, spacing){
	this.gl = glContext
	this.lineLength = 13
	this.vertexBuffer = new Float32Array(num_lines * 2 * 3 * 2 * 2)//2pts per line, 3 floats per point, 1 line horizontal, 1 vertical
	this.vertexBufferID
	this.init = function(){
		this.vertexBufferID = gl.createBuffer()
		if (!this.vertexBufferID) console.log('Failed to create tgorund plane vertex buffer');
		
		var start = -( spacing * (num_lines/2) )//the position the first line starts at
		var end = start * -1
		var i = 0
		for(var pos=start; pos <= (end*2); pos=pos+spacing){
			//extend down z
			this.vertexBuffer[i] = pos //X
			this.vertexBuffer[i+1] = 0 //Y
			this.vertexBuffer[i+2] = -(this.lineLength/2) //Z
			                   
			this.vertexBuffer[i+3] = pos //X
			this.vertexBuffer[i+4] = 0 //Y
			this.vertexBuffer[i+5] = (this.lineLength/2) //Z
			
			//extend down x
			this.vertexBuffer[i+6] = -(this.lineLength/2) //X
			this.vertexBuffer[i+7] = 0 //Y
			this.vertexBuffer[i+8] = pos //Z
			                    
			this.vertexBuffer[i+9] = (this.lineLength/2) //X
			this.vertexBuffer[i+10] = 0 //Y
			this.vertexBuffer[i+11] = pos //Z
			
			i = i + 12
		}
		console.log(this.vertexBuffer)
		
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBufferID);
		gl.bufferData(gl.ARRAY_BUFFER, this.vertexBuffer, gl.STATIC_DRAW);
		
		
	}
	this.draw = function(){
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBufferID);
		
		//attributeID, size of vector, type, normalized?, stride, offset
		gl.vertexAttribPointer(a_PositionID,3,gl.FLOAT, false, 0,0)
		
		gl.drawArrays(gl.LINES, 0, num_lines * 4);
	}


}

//A particle system is "renderable", meaning it takes gl context as input and provides a draw function
var ParticleSystem = function(glContext){
	this.gl = glContext
	
	this.particleBufferSize = 1000 //starting size of buffer
	this.numParticles = 0 //0 particles to start out
	this.particleBuffers = {//all buffers start as null
		ps0      : null,
		ps0dot   : null,
		ps1      : null,
		ps1dot   : null,
		psMid    : null,
		psMidDot : null,
	}
	this.ps0BufferID
	this.ps1BufferID
	this.activeParticleBuffer
	this.activeParticleBufferID
	
	this.forceBufferSize = 100 //starting size of buffer
	this.numForces = 0 //0 forces to start out
	this.forceBuffer 
	
	this.wallBufferSize = 30 //starting size of buffer
	this.numWalls = 0 //0 walls to start out
	this.wallBuffer
	
	//an enumeration
	this.particle_vars = {
		PART_XPOS     : 0,  //  position    
		PART_YPOS     : 1,
		PART_ZPOS     : 2,
		PART_XVEL     : 3, //  velocity    
		PART_YVEL     : 4,
		PART_ZVEL     : 5,
		PART_X_FTOT   : 6,  // force accumulator:'ApplyForces()' fcn clears
		PART_Y_FTOT   : 7,  // to zero, then adds each force to each particle.
		PART_Z_FTOT   : 8,        
		PART_R        : 9,  // color : red,green,blue
		PART_G        :10,  
		PART_B        :11,
		PART_MASS     :12,  // mass   
		PART_DIAM 	  :13,	// on-screen diameter (in pixels)
		PART_RENDMODE :14,	// on-screen appearance (square, round, or soft-round)
		PART_AGE      :15,  // # of frame-times since creation/initialization
		PART_CHARGE   :16,  // for electrostatic repulsion/attraction
		PART_MASS_VEL :17,  // time-rate-of-change of mass.
		PART_MASS_FTOT:18,  // force-accumulator for mass-change
		
		PARTICLE_STRIDE:19,  // Size of array in CPart uses to store its values.
	}
	this.affected_particle_set = {
		ALL:0,
		PART_INDEX1:1,
		BOTH_1_2:2,
	}
	this.wall_vars= {
		wall_types: {
			WTYPE_DEAD       :0,   // not in use
			WTYPE_BOXIN		 :1,
			WTYPE_BOXOUT     :2,
			WTYPE_SPHERE     :3,  // solid sphere centered at particle with index e0;
			// no other particles allowed closer than 'radmin'
			// to the e0 particle.
			// (NOTE: e0 is a state-vector index: pS0[e0] )
			
			WTYPE_STICK      :4,  // Connects 2 particles with fixed-length separation
			// between particles whose indices are held in e0,e1
			// (e.g. particles at pS0[e0] and pS0[e1] )
			WTYPE_PULLEY     :5,  // Keep constant sum-of-distances for 3 particles
			// A,B,Pivot:  ||A-Pivot||+||B-Pivot|| = dmax.
			WTYPE_ANCHOR     :6,  // Lock one particle at location xpos,ypos,zpos
		},
		TYPE:0, //one of the "wall_types" from above
		KBOUNCY:1,//how bouncy is this wall
		WALL_XPOS:2,
		WALL_YPOS:3,
		WALL_ZPOS:4,
		SIZE:5,
		AFFECTED_PARTICLES:6,//instance of "affected particle set"
		PART_INDEX1:7,		 //index of particle affected by constraint
		PART_INDEX2:8,
		
		WALL_STRIDE:9, //stride of a wall object
	}
	this.force_vars = {
		force_types: {
			F_NONE      :0,       // Non-existent force: ignore this CForcer object
			F_MOUSE     :1,       // Spring-like connection to the mouse cursor; lets
			// you 'grab' and 'wiggle' one particle(or several).
			F_GRAV_E    :2,       // Earth-gravity: pulls all particles 'downward'.
			F_GRAV_P    :3,       // Planetary-gravity; particle-pair (e0,e1) attract
			// each other with force== grav* mass0*mass1/ dist^2
			F_WIND      :4,       // Blowing-wind-like force-field;fcn of 3D position
			F_BUBBLE    :5,       // Constant inward force towards centerpoint if
			// particle is > max_radius away from centerpoint.
			F_DRAG      :6,       // Viscous drag -- proportional to neg. velocity.
			F_SPRING    :7,       // ties together 2 particles; distance sets force
			F_SPRINGSET :8,       // a big collection of identical springs; lets you
			// make cloth & rubbery shapes as one force-making
			// object, instead of many many F_SPRING objects.
			F_CHARGE    :9,       // attract/repel by charge and inverse distance;
			// applies to all charged particles.
		},
		TYPE:0,//one of the force_types from above
		POSX:1,
		POSY:2,
		POSZ:3,
		DIRX:4,
		DIRY:5,
		DIRZ:6,
		STRENGTH:7,
		REST_STRENGTH:8,// Less than this treat as strength zero
		AFFECTED_PARTICLES:9,//type "affected particle set"
		PART_INDEX1:10,
		PART_INDEX2:11,
		
		FORCE_STRIDE:12,
	}
	this.initBuffers = function(){
		this.forceBuffer = new Float32Array(this.forceBufferSize * this.force_vars.FORCE_STRIDE)
		this.wallBuffer = new Float32Array(this.wallBufferSize * this.wall_vars.WALL_STRIDE)
	
		for(key in this.particleBuffers){
			this.particleBuffers[key] = new Float32Array(this.particleBufferSize * this.particle_vars.PARTICLE_STRIDE);
		}
		
		this.ps0BufferID = gl.createBuffer()
		this.ps1BufferID = gl.createBuffer()
		
		this.activeParticleBuffer = this.particleBuffers.ps0
		this.activeParticleBufferID = this.ps0BufferID
		
		gl.bindBuffer(gl.ARRAY_BUFFER, this.ps0BufferID);
		gl.bufferData(gl.ARRAY_BUFFER, this.particleBuffers.ps0, gl.DYNAMIC_DRAW);
	}
	//example addForce({TYPE:F_GRAV_E, AFECTED_PARTICLES: ALL}
	this.addForce = function( array_literal ){
		this.numForces += 1
		if(this.numForces > this.forceBufferSize){
			alert("cannot add more particles. need to implement buffer resizing")
			return
		}
		
		//current force index
		var i = (this.numForces-1) * this.force_vars.FORCE_STRIDE
		
		//iterate through array_literal and add to buffer
		for(key in array_literal){
		
			//get value
			var value = array_literal[key]
			if(key == "TYPE")//special case since type must be converted to int
				value = this.force_vars.force_types[value]
			if(key == "AFFECTED_PARTICLES")
				value = this.affected_particle_set[value]
		
			//set value
			var var_offset = this.force_vars[key]
			this.forceBuffer[i + var_offset] =  value
		}
			
	
	}
	//example addForce({TYPE:F_GRAV_E, AFECTED_PARTICLES: ALL}
	this.addWall = function( array_literal ){
		this.numWalls += 1
		if(this.numWalls > this.wallBufferSize){
			alert("cannot add more walls. need to implement buffer resizing")
			return
		}
		
		//current force index
		var i = (this.numWalls-1) * this.wall_vars.WALL_STRIDE
		
		//iterate through array_literal and add to buffer
		for(key in array_literal){
		
			//get value
			var value = array_literal[key]
			if(key == "TYPE")//special case since type must be converted to int
				value = this.wall_vars.wall_types[value]
			if(key == "AFFECTED_PARTICLES")
				value = this.affected_particle_set[value]
		
			//set value
			var var_offset = this.wall_vars[key]
			this.wallBuffer[i + var_offset] =  value
		}
	}
	this.addParticle = function( array_literal ){
		this.numParticles += 1
		if(this.numParticles > this.particlesBufferSize){
			alert("cannot add more Particles. need to implement buffer resizing")
			return
		}
		
		//current force index
		var i = (this.numParticles-1) * this.particle_vars.PARTICLE_STRIDE
		
		//iterate through array_literal and add to buffer
		for(key in array_literal){
			//set value
			var var_offset = this.particle_vars[key]
			this.activeParticleBuffer[i + var_offset] =  array_literal[key]
		}
	}
	this.addBox = function(x,y,z,legth,WTYPE_BOXIN_OR_WTYPE_BOXOUT){
		this.addWall({
			TYPE:WTYPE_BOXIN_OR_WTYPE_BOXOUT,
			KBOUNCY:0.8,
			WALL_XPOS:x,
			WALL_YPOS:y,
			WALL_ZPOS:z,
			SIZE:length,
			AFFECTED_PARTICLES:"ALL"
		})
	}
	this.addSphere = function(x,y,x,radius){
		this.addWall({
			TYPE:"WTYPE_SPHERE",
			KBOUNCY:0.8,
			WALL_XPOS:x,
			WALL_YPOS:y,
			WALL_ZPOS:z,
			SIZE:radius,
			AFFECTED_PARTICLES:"ALL"
		})
	
	}
	this.addGravity = function(strength){
		this.addForce({
			TYPE:"F_GRAV_E", 
			AFECTED_PARTICLES: "ALL",
		})
	}
	this.addWind = function(x,y,z,dirX,dirY,dirZ, strength){
	
	}
	this.addFlock = function(x,y,z){
	
	}
	this.shootParticleMouseHandler = function(ev){
		this.addParticle({
			"PART_XPOS":0,
			"PART_YPOS":5,
			"PART_ZPOS":-2,
		})
	}
	this.solvers = {
	
	}
	this.sovler = null
	this.getForceVar = function(i,var_name){
		return this.forceBuffer[ (i * this.force_vars.FORCE_STRIDE) + this.force_vars[var_name] ]
	}
	this.getParticleVar = function(i,var_name){
		return this.activeParticleBuffer[ (i * this.particle_vars.PARTICLE_STRIDE) + this.particle_vars[var_name] ]
	}
	this.setParticleVar = function(i, var_name, value){
		this.activeParticleBuffer[ (i * this.particle_vars.PARTICLE_STRIDE) + this.particle_vars[var_name] ] = value
	}
	this.applyAllForces = function(){
		//apply velocities
		for(var i = 0; i < this.numForces; i++){
		
			var force_type = this.getForceVar(i,"TYPE")
			switch(force_type){
				case 2://F_GRAV_E
					for(var p = 0; p < this.numParticles; p++){
						var yvel = this.getParticleVar(p, "PART_YVEL")
						this.setParticleVar(p,"PART_YVEL", yvel - 0.0025)
					}
			}
		}
		//move particles according to velocity
		for(var p = 0; p < this.numParticles; p++){
			var zvel = this.getParticleVar(p, "PART_ZVEL")
			var xvel = this.getParticleVar(p, "PART_XVEL")
			var yvel = this.getParticleVar(p, "PART_YVEL")
			
			var zpos = this.getParticleVar(p, "PART_ZPOS")
			var xpos = this.getParticleVar(p, "PART_XPOS")
			var ypos = this.getParticleVar(p, "PART_YPOS")
			
			this.setParticleVar(p,"PART_ZPOS", zpos + zvel)
			this.setParticleVar(p,"PART_XPOS", xpos + xvel)
			this.setParticleVar(p,"PART_YPOS", ypos + yvel)
		}
	
	}
	this.applyAllWalls = function(){
	
	}
	this.draw = function(){
		this.applyAllForces()
		this.applyAllWalls()
		
		gl.bindBuffer(gl.ARRAY_BUFFER, this.activeParticleBufferID);
		gl.bufferData(gl.ARRAY_BUFFER, this.activeParticleBuffer, gl.DYNAMIC_DRAW);
		//attributeID, size of vector, type, normalized?, stride, offset
		var stride = this.particle_vars.PARTICLE_STRIDE * this.activeParticleBuffer.BYTES_PER_ELEMENT
		gl.vertexAttribPointer(a_PositionID,3,gl.FLOAT, false, stride,0)
		gl.drawArrays(gl.POINTS, 0, this.numParticles);
	}
	/*
	this.dotMaker = function(CPart *pDotDest, CPart *pSrc
	, CForcer *pF, CWall *pW)){
		
	}
	this.applyAllForces = function(CPart *pS, CForcer *pF);
	this.applyAllWalls = function(CPart *pS_now, CPart *pS_prev,  CWall *pWsrc);
	this.stateVecSwap = function(CPart **ppA, CPart **ppB);
	
	void stateVecSizer(int nuSize);// For each state vector, create a new array
	// (dyn. allocation) of particles.  Discard
	// any previous particles (if any) and if
	// successful, set partCount to 'nuSize'.
	// (NOTE: same size for all state-vectors).
	void stateVecWipe(void);        // Discard all existing memory allocated for
	// state vectors in this CPartSys.

	void stateVecDraw(CPart *pS);   // Draw state-vector pS usingOpenGL calls.

	// Math operators (BETTER: use operator overloading!)
	void stateVecZero(CPart *pS);                   // set state to zero
	void stateVecAssign(CPart *pDest, CPart *pSrc); // copy src to dest
	void stateVecAplusBtimesC(CPart *pDest, CPart *pA, CPart *pB, double scl);
	// dest = A + scl*B

	//-------Force-List Vector(s)----------------
	int forcerCount;                // # of forcer-making objects held in the
	// dyn. alloc'd list at pF0 (if needed, in
	// pF1, pFM, pF0dot,pF1dot,pFMdot as well).
	CForcer *pF0;                   // f0; forcer-vector-- dyn. alloc'd list of
	// all CURRENT force-making objects,
	// *pF0dot;                     //  and its time-derivative f0dot
	// (==NULL if none).
	/*
	// OPTIONAL: as needed,
	//      create these additional forcer-vectors to implement time-dependent-
	//      and particle-dependent (?and wall-dependent?) force-making objects.
	//  !!CAREFUL!!! Be sure to update forcerVecSizer(), forcerVecWipe(),
	//               CPartSys() and ~CPartSys() for the new forcer-vectors;
	//  NOTE: all forcer-vectors are the same size (CPartSys:: forcerCount).
	CForcer *pF1, pF1dot;           // f1; forcer-vector--dyn. alloc'd list of
									// all NEXT force-making objects, and its
									// time-derivative f1dot (==NULL if none)
	CForcer *pFM, *pFMdot;          // fM, fMdot; midpoint forcer-vector and its
									// time deriv. (see solver, midpoint method)

	void forcerVecSizer(int nuSize);// Change the size of each dyn.-alloc'd list
	// of force-applying objects (CForcer obj.).
	// Discard any previous forcers (if any),
	// and if successful, set forcerCount to
	// nuSize.(same size for all forcer-vectors)
	void forcerVecWipe(void);       // Discard all existing memory allocated
	// for forcer-vectors in this CPartSys.
	void forcerVecDraw(CForcer *pF, CPart *pS);
	// Draw forcer-vector pF using OpenGL calls;
	// (needs corresponding state-vector at pS
	// because force-applying springs get their
	// positions in space from the particles
	// they connect together).
	//-------Wall-Vectors(s)---------------
	int wallCount;                  //# of constraint-making objects (CWall obj)
	// held in the dyn. alloc'd list at pC0.
	CWall *pC0;                     // c0; constraint-vector--dyn. alloc'd list
	// of all CURRENT constraint-making objects,
	//CWall *pC0dot;                  // and its time-derivative c0dot
	// (==NULL if none).
	// OPTIONAL: as needed,
	//      create these additional wall-vectors to implement time-dependent-0
	//      and particle-dependent (?and forcer-dependent?) wall-making objects.
	// !!CAREFUL!! Be sure to update wallVecSizer(), wallVecWipe(), CPartSys()
	//      and ~CPartSys() for the new forcer-vectors.
	// NOTE: same size for all wall-vectors)
	void wallVecSizer(int nuSiz);   // For each limit-vector, create (by dyn.
	// allocation) an new array of constraints
	// (CLimit objects). Discard any prev.
	// constraints (if any), and if successful,
	// set limitCount to nuSiz.
	// (NOTE: same size for all limit-vectors).
	void wallVecWipe(void);         // Discard all existing memory allocated
	// for wall-vectors in this CPartSys.
	void wallVecDraw(CWall *pC);    // Draw the wall-vector pC with OpenGL calls
	
	*/

}

var utils =  {
	
	getShader : function(gl, elementId) {
		var shaderScript, theSource, currentChild, shader;

		var shaderScript = document.getElementById(elementId);
		var theSource = "";
		var currentChild = shaderScript.firstChild;

		while(currentChild) {
			if (currentChild.nodeType == currentChild.TEXT_NODE) {
				theSource += currentChild.textContent;
			}
			currentChild = currentChild.nextSibling;
		}
		
		if (shaderScript.type == "x-shader/x-fragment") {
			shader = gl.createShader(gl.FRAGMENT_SHADER);
		} else if (shaderScript.type == "x-shader/x-vertex") {
			shader = gl.createShader(gl.VERTEX_SHADER);
		} else {
			return null;
		}

		gl.shaderSource(shader, theSource);
		gl.compileShader(shader);  
		
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {  
			alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));  
			return null;  
		}
		
		return shader;
	},
	lastTime: 0,
	elapsedTime: function(sinceTime) {
		if (!lastTime)  lastTime = Date.now();
		return Date.now() - sinceTime;	
	},
};


var rend = new Renderer()
rend.start()



</script>
</body>
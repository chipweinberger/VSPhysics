<body>
<canvas id="glcanvas" width="1024" height="768">
</canvas>

<script src="lib/webgl-utils.js"></script>
<script src="lib/webgl-debug.js"></script>
<script src="lib/cuon-utils.js"></script>
<script src="lib/cuon-matrix-quat.js"></script> 


<script id="fragmentShader" type="x-shader/x-fragment">
precision mediump float;

varying vec4 vColor;

void main(void) {
	gl_FragColor = vec4(1.0,1.0,1.0,1.0);
}
</script>

<script id="vertexShader" type="x-shader/x-vertex">
attribute vec3 a_Position;

uniform mat4 uViewMatrix;
uniform mat4 uProjMatrix;

varying vec4 vColor;

void main(void) {
	gl_Position = uProjMatrix * uViewMatrix * vec4(a_Position, 1.0);
	gl_PointSize = 10.0;
	vColor = vec4(1.0,1.0,1.0,1.0);
}
</script>


<script type="text/javascript">

//globals
var gl //context
var a_PositionID 
var a_ColorID 
var canvas //canvas element

var Renderer = function(){
	 var Camera = function(){
		//look down the z negative axis
		this.eyeX = 0
		this.eyeY = 0.5
		this.eyeZ = 0
		this.atX = 0
		this.atY = 0
		this.atZ = -1
		this.upX = 0
		this.upY = 1
		this.upZ = 0
		this.fovy  = 70
		this.aspect  = 1.0
		this.near = .01
		this.far  = 100
		this.projectionMatrix = function(){
			return new Matrix4().setPerspective(this.fovy, this.aspect, this.near, this.far)
		}
		this.viewMatrix = function(){
			return new Matrix4().setLookAt(this.eyeX, this.eyeY, this.eyeZ, this.atX, this.atY, this.atZ, this.upX, this.upY, this.upZ)
		}
	}
	this.cam0 = new Camera()
	this.uViewMatrixID
	this.uProjMatrixID 
	this.partSys
	this.ground_plane
	this.start = function(){
	
		//gl setup
		canvas = document.getElementById("glcanvas")
		gl = WebGLUtils.setupWebGL(canvas)

		gl.viewport(0,0,1024,768)
		gl.clearColor(0.0, 0.0, 0.0, 1.0)                     
		gl.enable(gl.DEPTH_TEST)                              
		gl.depthFunc(gl.LEQUAL)  

		//compile shaders
		var fragmentShader = utils.getShader(gl, "fragmentShader");
		var vertexShader = utils.getShader(gl, "vertexShader");
		
		// Create the shader program
		shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);

		// If creating the shader program failed, alert

		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			alert("Unable to initialize the shader program.");
		}

		gl.useProgram(shaderProgram);
		
		//position attribute
		a_PositionID = gl.getAttribLocation(shaderProgram, 'a_Position')
		if(a_PositionID < 0) console.log('Failed to get the gfx storage location of a_Position')
		gl.enableVertexAttribArray(a_PositionID);
		
		
		//projection matrix location
		uProjMatrixID = gl.getUniformLocation(shaderProgram, 'uProjMatrix')
		if(uProjMatrixID < 0) console.log('Failed to get the gfx storage location of uProjMatrix')
		
		//view matrix location
		uViewMatrixID = gl.getUniformLocation(shaderProgram, 'uViewMatrix')
		if(uViewMatrixID < 0) console.log('Failed to get the gfx storage location of uViewMatrix')
		
		//groundplane
		this.ground_plane = new GroundPlane(gl,"Y", 30, .2)
		this.ground_plane.init()
		
		//particle system
		//this.partSys = particle_system()
		
		window.requestAnimationFrame(this.draw.bind(this));
		
	}
	this.draw = function(){
		gl.clear(gl.COLOR_BUFFER_BIT)
		
		//set camera placement
		gl.uniformMatrix4fv(uProjMatrixID, false, this.cam0.projectionMatrix().elements)
		gl.uniformMatrix4fv(uViewMatrixID, false, this.cam0.viewMatrix().elements)
		
		this.ground_plane.draw()
		//partSys.draw()
		
		window.requestAnimationFrame(this.draw.bind(this));
	}

}


//A ground plane is "renderable", meaning it takes gl context as input and provides a draw function
//axis == "X" "Y" or "Z" meaning x==0 y==0 or z==0
var GroundPlane = function(glContext, axis, num_lines, spacing){
	this.gl = glContext
	this.lineLength = 100
	this.vertexBuffer = new Float32Array(num_lines * 2 * 3 * 2)//2pts per line, 3 floats per point, 1 line horizontal, 1 vertical
	this.vertexBufferID
	this.init = function(){
		this.vertexBufferID = gl.createBuffer()
		if (!this.vertexBufferID) console.log('Failed to create tgorund plane vertex buffer');
		
		var start = -( spacing * (num_lines/2) )//the position the first line starts at
		var end = start * -1
		var i = 0
		for(var pos=start; pos <= end; pos=pos+spacing){
			//extend down z
			this.vertexBuffer[i] = pos //X
			this.vertexBuffer[i+1] = 0 //Y
			this.vertexBuffer[i+2] = -(this.lineLength/2) //Z
			                   
			this.vertexBuffer[i+3] = pos //X
			this.vertexBuffer[i+4] = 0 //Y
			this.vertexBuffer[i+5] = (this.lineLength/2) //Z
			
			//extend down x
			this.vertexBuffer[i+6] = -(this.lineLength/2) //X
			this.vertexBuffer[i+7] = 0 //Y
			this.vertexBuffer[i+8] = pos //Z
			                    
			this.vertexBuffer[i+9] = (this.lineLength/2) //X
			this.vertexBuffer[i+10] = 0 //Y
			this.vertexBuffer[i+11] = pos //Z
			
			i = i + 12
		}
		console.log(this.vertexBuffer)
		
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBufferID);
		gl.bufferData(gl.ARRAY_BUFFER, this.vertexBuffer, gl.STATIC_DRAW);
		
		
	}
	this.draw = function(){
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBufferID);
		
		//attributeID, size of vector, type, normalized?, stride, offset
		gl.vertexAttribPointer(a_PositionID,3,gl.FLOAT, false, 0,0)
		
		
		gl.drawArrays(gl.LINES, 0, num_lines * 2);
	}


}

//A particle system is "renderable", meaning it takes gl context as input and provides a draw function
var ParticleSystem = function(num_particles, glContext){
	this.gl = glContext
	this.numParticles = num_particles
	//an enumeration
	var particle_vars = {
		PART_XPOS     : 0,  //  position    
		PART_YPOS     : 1,
		PART_ZPOS     : 2,
		PART_XVEL     : 3, //  velocity    
		PART_YVEL     : 4,
		PART_ZVEL     : 5,
		PART_X_FTOT   : 6,  // force accumulator:'ApplyForces()' fcn clears
		PART_Y_FTOT   : 7,  // to zero, then adds each force to each particle.
		PART_Z_FTOT   : 8,        
		PART_R        : 9,  // color : red,green,blue
		PART_G        :10,  
		PART_B        :11,
		PART_MASS     :12,  // mass   
		PART_DIAM 	  :13,	// on-screen diameter (in pixels)
		PART_RENDMODE :14,	// on-screen appearance (square, round, or soft-round)
		PART_AGE      :15,  // # of frame-times since creation/initialization
		PART_CHARGE   :16,  // for electrostatic repulsion/attraction
		PART_MASS_VEL :17,  // time-rate-of-change of mass.
		PART_MASS_FTOT:18,  // force-accumulator for mass-change
		
		PARTICLE_STRIDE:19,  // Size of array in CPart uses to store its values.
	}
	var affected_particle_set = {
		ALL:0,
		PART_INDEX1:1,
		BOTH_1_2:2,
	}
	var wall_vars= {
		wall_types: {
			WTYPE_DEAD       :0,   // not in use
			WTYPE_BOXIN		 :1,
			WTYPE_BOXOUT     :2,
			WTYPE_SPHERE     :3,  // solid sphere centered at particle with index e0;
			// no other particles allowed closer than 'radmin'
			// to the e0 particle.
			// (NOTE: e0 is a state-vector index: pS0[e0] )
			
			WTYPE_STICK      :4,  // Connects 2 particles with fixed-length separation
			// between particles whose indices are held in e0,e1
			// (e.g. particles at pS0[e0] and pS0[e1] )
			WTYPE_PULLEY     :5,  // Keep constant sum-of-distances for 3 particles
			// A,B,Pivot:  ||A-Pivot||+||B-Pivot|| = dmax.
			WTYPE_ANCHOR     :6,  // Lock one particle at location xpos,ypos,zpos
		},
		TYPE:0, //one of the "wall_types" from above
		KBOUNCY:1,//how bouncy is this wall
		WALL_XPOS:2,
		WALL_YPOS:3,
		WALL_ZPOS:4,
		SIZE:5,
		AFFECTED_PARTICLES:6,//instance of "affected particle set"
		PART_INDEX1:7,		 //index of particle affected by constraint
		PART_INDEX2:8,
		
		WALL_STRIDE:9, //stride of a wall object
	}
	var force_vars = {
		force_types: {
			F_NONE      :0,       // Non-existent force: ignore this CForcer object
			F_MOUSE     :1,       // Spring-like connection to the mouse cursor; lets
			// you 'grab' and 'wiggle' one particle(or several).
			F_GRAV_E    :2,       // Earth-gravity: pulls all particles 'downward'.
			F_GRAV_P    :3,       // Planetary-gravity; particle-pair (e0,e1) attract
			// each other with force== grav* mass0*mass1/ dist^2
			F_WIND      :4,       // Blowing-wind-like force-field;fcn of 3D position
			F_BUBBLE    :5,       // Constant inward force towards centerpoint if
			// particle is > max_radius away from centerpoint.
			F_DRAG      :6,       // Viscous drag -- proportional to neg. velocity.
			F_SPRING    :7,       // ties together 2 particles; distance sets force
			F_SPRINGSET :8,       // a big collection of identical springs; lets you
			// make cloth & rubbery shapes as one force-making
			// object, instead of many many F_SPRING objects.
			F_CHARGE    :9,       // attract/repel by charge and inverse distance;
			// applies to all charged particles.
		},
		TYPE:0,//one of the force_types from above
		POSX:1,
		POSY:2,
		POSZ:3,
		DIRX:4,
		DIRY:5,
		DIRZ:6,
		STRENGTH:7,
		REST_STRENGTH:8,// Less than this treat as strength zero
		AFFECTED_PARTICLES:9,//type "affected particle set"
		PART_INDEX1:10,
		PART_INDEX2:11,
		
		FORCE_STRIDE:12,
	}
	this.buffers = {//all buffers start as null
		ps0      : null,
		ps0      : null,
		ps0dot   : null,
		ps1      : null,
		ps1dot   : null,
		psMid    : null,
		psMidDot : null,
	}
	//solving
	this.initBuffers = function(){
		for(key in buffers){
			buffers[key] = new Float32Array(numParticles * particle_vars.PARTICLE_STRIDE);
		}
	}
	this.sovler = null
	/*
	this.dotMaker = function(CPart *pDotDest, CPart *pSrc, CForcer *pF, CWall *pW)){
		
	}
	this.applyAllForces = function(CPart *pS, CForcer *pF);
	this.applyAllWalls = function(CPart *pS_now, CPart *pS_prev,  CWall *pWsrc);
	this.stateVecSwap = function(CPart **ppA, CPart **ppB);
	
	void stateVecSizer(int nuSize);// For each state vector, create a new array
	// (dyn. allocation) of particles.  Discard
	// any previous particles (if any) and if
	// successful, set partCount to 'nuSize'.
	// (NOTE: same size for all state-vectors).
	void stateVecWipe(void);        // Discard all existing memory allocated for
	// state vectors in this CPartSys.

	void stateVecDraw(CPart *pS);   // Draw state-vector pS usingOpenGL calls.

	// Math operators (BETTER: use operator overloading!)
	void stateVecZero(CPart *pS);                   // set state to zero
	void stateVecAssign(CPart *pDest, CPart *pSrc); // copy src to dest
	void stateVecAplusBtimesC(CPart *pDest, CPart *pA, CPart *pB, double scl);
	// dest = A + scl*B

	//-------Force-List Vector(s)----------------
	int forcerCount;                // # of forcer-making objects held in the
	// dyn. alloc'd list at pF0 (if needed, in
	// pF1, pFM, pF0dot,pF1dot,pFMdot as well).
	CForcer *pF0;                   // f0; forcer-vector-- dyn. alloc'd list of
	// all CURRENT force-making objects,
	// *pF0dot;                     //  and its time-derivative f0dot
	// (==NULL if none).
	/*
	// OPTIONAL: as needed,
	//      create these additional forcer-vectors to implement time-dependent-
	//      and particle-dependent (?and wall-dependent?) force-making objects.
	//  !!CAREFUL!!! Be sure to update forcerVecSizer(), forcerVecWipe(),
	//               CPartSys() and ~CPartSys() for the new forcer-vectors;
	//  NOTE: all forcer-vectors are the same size (CPartSys:: forcerCount).
	CForcer *pF1, pF1dot;           // f1; forcer-vector--dyn. alloc'd list of
									// all NEXT force-making objects, and its
									// time-derivative f1dot (==NULL if none)
	CForcer *pFM, *pFMdot;          // fM, fMdot; midpoint forcer-vector and its
									// time deriv. (see solver, midpoint method)

	void forcerVecSizer(int nuSize);// Change the size of each dyn.-alloc'd list
	// of force-applying objects (CForcer obj.).
	// Discard any previous forcers (if any),
	// and if successful, set forcerCount to
	// nuSize.(same size for all forcer-vectors)
	void forcerVecWipe(void);       // Discard all existing memory allocated
	// for forcer-vectors in this CPartSys.
	void forcerVecDraw(CForcer *pF, CPart *pS);
	// Draw forcer-vector pF using OpenGL calls;
	// (needs corresponding state-vector at pS
	// because force-applying springs get their
	// positions in space from the particles
	// they connect together).
	//-------Wall-Vectors(s)---------------
	int wallCount;                  //# of constraint-making objects (CWall obj)
	// held in the dyn. alloc'd list at pC0.
	CWall *pC0;                     // c0; constraint-vector--dyn. alloc'd list
	// of all CURRENT constraint-making objects,
	//CWall *pC0dot;                  // and its time-derivative c0dot
	// (==NULL if none).
	// OPTIONAL: as needed,
	//      create these additional wall-vectors to implement time-dependent-0
	//      and particle-dependent (?and forcer-dependent?) wall-making objects.
	// !!CAREFUL!! Be sure to update wallVecSizer(), wallVecWipe(), CPartSys()
	//      and ~CPartSys() for the new forcer-vectors.
	// NOTE: same size for all wall-vectors)
	void wallVecSizer(int nuSiz);   // For each limit-vector, create (by dyn.
	// allocation) an new array of constraints
	// (CLimit objects). Discard any prev.
	// constraints (if any), and if successful,
	// set limitCount to nuSiz.
	// (NOTE: same size for all limit-vectors).
	void wallVecWipe(void);         // Discard all existing memory allocated
	// for wall-vectors in this CPartSys.
	void wallVecDraw(CWall *pC);    // Draw the wall-vector pC with OpenGL calls
	
	*/

}

var utils =  {
	
	getShader : function(gl, elementId) {
		var shaderScript, theSource, currentChild, shader;

		var shaderScript = document.getElementById(elementId);
		var theSource = "";
		var currentChild = shaderScript.firstChild;

		while(currentChild) {
			if (currentChild.nodeType == currentChild.TEXT_NODE) {
				theSource += currentChild.textContent;
			}
			currentChild = currentChild.nextSibling;
		}
		
		if (shaderScript.type == "x-shader/x-fragment") {
			shader = gl.createShader(gl.FRAGMENT_SHADER);
		} else if (shaderScript.type == "x-shader/x-vertex") {
			shader = gl.createShader(gl.VERTEX_SHADER);
		} else {
			return null;
		}

		gl.shaderSource(shader, theSource);
		gl.compileShader(shader);  
		
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {  
			alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));  
			return null;  
		}
		
		return shader;
	},
	lastTime: 0,
	elapsedTime: function(sinceTime) {
		if (!lastTime)  lastTime = Date.now();
		return Date.now() - sinceTime;	
	},
};


var rend = new Renderer()
rend.start()



</script>
</body>
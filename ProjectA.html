<body>
<button type="button" onclick="rend.partSys.addCharge(0,0,-2,5)">Add charge in middle</button>
<button type="button" onclick="rend.circleCamera = true">Circle Camera ON</button>
<button type="button" onclick="rend.circleCamera = false">Circle Camera OFF</button>
<button type="button" onclick="rend.partSys.fireOn = true">fire on</button>
<button type="button" onclick="rend.partSys.fireOn = false">fire off</button>
Camera Key Controls: (position) a,z,s,x,d,c (aim) arrow keys + f,v,
<br> click the mouse to shoot a particle
<br> note because I have not implemented garbage collection fire will destroy frame rate after awhile
<canvas id="glcanvas" width="1024" height="768">
</canvas>




<script src="lib/webgl-utils.js"></script>
<script src="lib/webgl-debug.js"></script>
<script src="lib/cuon-utils.js"></script>
<script src="lib/cuon-matrix-quat.js"></script> 


<script id="fragmentShader" type="x-shader/x-fragment">
precision highp float;

varying vec4 vColor;

void main(void) {
	gl_FragColor = vColor;
}
</script>

<script id="vertexShader" type="x-shader/x-vertex">
precision highp float;

attribute float a_Age;
attribute float disappear_age;
attribute vec3 a_Position;
attribute vec3 a_Color;

uniform mat4 uViewMatrix;
uniform mat4 uProjMatrix;
uniform mat4 uModelMatrix;

uniform float useConstColor;
uniform vec4 constColor;

varying vec4 vColor;

void main(void) {
	gl_Position = uProjMatrix * uViewMatrix * uModelMatrix * vec4(a_Position, 1.0);
	gl_PointSize = 10.0;
	
	if(a_Age < disappear_age || disappear_age == 0.0){
		if(useConstColor == 1.0)
			vColor = constColor;
		else
			vColor = vec4(a_Color, 1);
	}else{
		vColor = vec4(0,0,0,0);
	}
}
</script>


<script type="text/javascript">

//globals
var gl //context
var a_PositionID 
var a_ColorID 
var constColorID
var useConstColorID
var a_AgeID 
var disappear_ageID

var canvas //canvas element
var uModelMatrixID
var mouseDown = 0;
var MouseX
var MouseY

var Renderer = function(){
	 var Camera = function(){
		//look down the z negative axis
		this.eye = new Vector3([0,3,6])
		this.at = new Vector3([0,0,0])
		this.up = new Vector3([0,1,0])
		this.fovy  = 70
		this.aspect  = 1.0
		this.near = .01
		this.far  = 100
		
		this.pan = function(deg){
			this.at = new Matrix4().setRotate(-deg,this.up.x(),this.up.y(),this.up.z()).multiplyVector3(this.at)
		}
		this.tilt = function(deg){
			var crss = this.at.cross(this.up)//vec parrallel to both
			this.at = new Matrix4().setRotate(deg, crss.x(), crss.y(), crss.z()).multiplyVector3(this.at)
			this.up = new Matrix4().setRotate(deg, crss.x(), crss.y(), crss.z()).multiplyVector3(this.up)
		}
		this.roll = function(deg){
			this.up = new Matrix4().setRotate(deg,this.at.x(),this.at.y(),this.at.z()).multiplyVector3(this.up)
		}

		this.transX = function(unit){
			this.at.elements[0] = this.at.x() + unit
			this.eye.elements[0] = this.eye.x() + unit
		}
		this.transY = function(unit){
			this.at.elements[1] = this.at.y() + unit
			this.eye.elements[1] = this.eye.y() + unit
		}
		this.transZ = function(unit){
			this.at.elements[2] = this.at.z() + unit
			this.eye.elements[2] = this.eye.z() + unit
		}
		
		this.projectionMatrix = function(){
			return new Matrix4().setPerspective(this.fovy, this.aspect, this.near, this.far)
		}
		this.viewMatrix = function(){
			return new Matrix4().setLookAt(this.eye.x(), this.eye.y(), this.eye.z(), this.at.x(), this.at.y(), this.at.z(), this.up.x(), this.up.y(), this.up.z())
		}
		
		this.keyboardControl = function(ev){
			var speed = 2
			switch(ev.keyCode) {
				case 39://right arrow
					this.pan(speed);break
				case 37://left arrow
					this.pan(-speed);break
				case 38://up arrow
					this.tilt(speed);break
				case 40://down arrow
					this.tilt(-speed);break
				case 65://a
					this.transX(speed/40);break
				case 90://z
					this.transX(-speed/40);break
				case 83://s           
					this.transY(speed/40);break
				case 88://x           
					this.transY(-speed/40);break
				case 68://d           
					this.transZ(speed/40);break
				case 67://c           
					this.transZ(-speed/40);break
				case 70://f
					this.roll(speed);break
				case 86://v
					this.roll(-speed);break
			}
		
		}
		
	}
	this.cam0 = new Camera()
	this.circleCamera=true //circle the camera around center point
	this.uViewMatrixID
	this.uProjMatrixID 
	this.partSys
	this.ground_plane
	this.start = function(){
	
		//gl setup
		canvas = document.getElementById("glcanvas")
		canvas.width = window.innerWidth * .90
		canvas.height = window.innerHeight * .90
		gl = WebGLUtils.setupWebGL(canvas)

		gl.viewport(0,0,canvas.width,canvas.height)
		gl.clearColor(0.0, 0.0, 0.0, 1.0)                     
		//gl.enable(gl.DEPTH_TEST) 
		gl.enable(gl.BLEND);
		gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
		gl.depthFunc(gl.LEQUAL)  

		//compile shaders
		var fragmentShader = utils.getShader(gl, "fragmentShader");
		var vertexShader = utils.getShader(gl, "vertexShader");
		
		// Create the shader program
		shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);

		// If creating the shader program failed, alert

		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			alert("Unable to initialize the shader program.");
		}

		gl.useProgram(shaderProgram);
		
		//position attribute
		a_PositionID = gl.getAttribLocation(shaderProgram, 'a_Position')
		if(a_PositionID < 0) console.log('Failed to get the gfx storage location of a_Position')
		gl.enableVertexAttribArray(a_PositionID);
		
		//color attribute
		a_ColorID = gl.getAttribLocation(shaderProgram, 'a_Color')
		if(a_ColorID < 0) console.log('Failed to get the gfx storage location of a_Color')
		
		//age attribute
		a_AgeID = gl.getAttribLocation(shaderProgram, 'a_Age')
		if(a_AgeID < 0) console.log('Failed to get the gfx storage location of a_Age')
		
		disappear_ageID = gl.getAttribLocation(shaderProgram, 'disappear_age')
		
		
		useConstColorID = gl.getUniformLocation(shaderProgram, 'useConstColor')
		constColorID = gl.getUniformLocation(shaderProgram, 'constColor')
		
		
		
		//projection matrix location
		uProjMatrixID = gl.getUniformLocation(shaderProgram, 'uProjMatrix')
		if(uProjMatrixID < 0) console.log('Failed to get the gfx storage location of uProjMatrix')
		
		//view matrix location
		uViewMatrixID = gl.getUniformLocation(shaderProgram, 'uViewMatrix')
		if(uViewMatrixID < 0) console.log('Failed to get the gfx storage location of uViewMatrix')
		
		//model matrix location
		uModelMatrixID = gl.getUniformLocation(shaderProgram, 'uModelMatrix')
		if(uModelMatrixID < 0) console.log('Failed to get the gfx storage location of uModelMatrix')
		
		
		//groundplane
		this.ground_plane = new GroundPlane(gl,"Y", 60, .2)
		this.ground_plane.init()
		
		//particle system
		this.partSys = new ParticleSystem(gl)
		this.partSys.initBuffers()
		
		//keyboard control
		window.addEventListener("keydown", this.cam0.keyboardControl.bind(this.cam0), false);
		
		document.body.onmousedown = function() { 
			  mouseDown = true;
		}
		
		document.body.onmouseup = function() {
			mouseDown = false;
		}
		
		document.body.onmousemove = function(ev) {
				var rect = ev.target.getBoundingClientRect();	    // get canvas corners in pixels
				MouseX = ev.clientX - rect.left;					//x==0 at canvas left edge
				MouseY = canvas.height - (ev.clientY - rect.top);	//y==0 at canvas bottom edge
				
				this.partSys.shootParticle(MouseX,MouseY)
		}
		
		
		//add gravity
		this.partSys.addGravity()
		this.partSys.addBoxIn(0,6,0,6)
		this.partSys.addSphere(-3,3,0,1.2)
		this.partSys.addBoxOut(0,2,-3,.8)
		this.partSys.addBoidFlock(0,2,3,30)
		this.partSys.addCloth(1,2,-1)
		
		window.requestAnimationFrame(this.draw.bind(this));
		
	}
	var counter = 300
	this.draw = function(){
		gl.clear(gl.COLOR_BUFFER_BIT)
		
		
		if(this.circleCamera){
			counter++
			this.cam0.eye = new Matrix4().rotate(0.17, 0, 1, 0).multiplyVector3(this.cam0.eye)
			this.cam0.eye.elements[1] = -Math.sin(counter/70)*1.4 + 3 //up and down y
		}
			
		
		//set camera placement
		gl.uniformMatrix4fv(uProjMatrixID, false, this.cam0.projectionMatrix().elements)
		gl.uniformMatrix4fv(uViewMatrixID, false, this.cam0.viewMatrix().elements)
		
		//model matrix is used by the models - set to identity for now
		gl.uniformMatrix4fv(uModelMatrixID, false, new Matrix4().elements)
		
		
		this.ground_plane.draw()
		this.partSys.draw()
		
		window.requestAnimationFrame(this.draw.bind(this));
	}

}


//A ground plane is "renderable", meaning it takes gl context as input and provides a draw function
//axis == "X" "Y" or "Z" meaning x==0 y==0 or z==0
var GroundPlane = function(glContext, axis, num_lines, spacing){
	this.gl = glContext
	this.lineLength = 13
	this.vertexBuffer = new Float32Array(num_lines * 2 * 3 * 2 * 2)//2pts per line, 3 floats per point, 1 line horizontal, 1 vertical
	this.vertexBufferID
	this.init = function(){
		this.vertexBufferID = gl.createBuffer()
		if (!this.vertexBufferID) console.log('Failed to create tgorund plane vertex buffer');
		
		var start = -( spacing * (num_lines/2) )//the position the first line starts at
		var end = start * -1
		var i = 0
		for(var pos=start; pos <= (end*2); pos=pos+spacing){
			//extend down z
			this.vertexBuffer[i] = pos //X
			this.vertexBuffer[i+1] = 0 //Y
			this.vertexBuffer[i+2] = -(this.lineLength/2) //Z
			                   
			this.vertexBuffer[i+3] = pos //X
			this.vertexBuffer[i+4] = 0 //Y
			this.vertexBuffer[i+5] = (this.lineLength/2) //Z
			
			//extend down x
			this.vertexBuffer[i+6] = -(this.lineLength/2) //X
			this.vertexBuffer[i+7] = 0 //Y
			this.vertexBuffer[i+8] = pos //Z
			                    
			this.vertexBuffer[i+9] = (this.lineLength/2) //X
			this.vertexBuffer[i+10] = 0 //Y
			this.vertexBuffer[i+11] = pos //Z
			
			i = i + 12
		}
		console.log(this.vertexBuffer)
		
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBufferID);
		gl.bufferData(gl.ARRAY_BUFFER, this.vertexBuffer, gl.STATIC_DRAW);
		
		
	}
	this.draw = function(){
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBufferID);
		
		//attributeID, size of vector, type, normalized?, stride, offset
		gl.vertexAttribPointer(a_PositionID,3,gl.FLOAT, false, 0,0)
		
		gl.uniform1f(useConstColorID, 1.0)
		gl.uniform4fv(constColorID, new Float32Array([1,0,1,1]))
		gl.drawArrays(gl.LINES, 0, num_lines * 4);
		gl.uniform1f(useConstColorID, 0.0)
	}
}

//drawable
var Box = function(x,y,z,len){
		this.vertexID = gl.createBuffer()
		this.indexID = gl.createBuffer()
		this.x = x
		this.y = y 
		this.z = z
		this.size = len
        this.vertices = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
			-1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,

        ]
        this.cubeVertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
		this.draw = function(){
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexID);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
			
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexID);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.cubeVertexIndices), gl.STATIC_DRAW);
			
			gl.vertexAttribPointer(a_PositionID,3,gl.FLOAT, false, 0,0)
			
			//set model matrix
			var scale = new Matrix4().setScale(this.size, this.size, this.size)
			var model = new Matrix4().setTranslate(this.x, this.y, this.z).multiply( scale ) 
			gl.uniformMatrix4fv(uModelMatrixID, false, model.elements)
			
			gl.uniform1f(useConstColorID, 1.0)
			gl.uniform4fv(constColorID, new Float32Array([0,0.8,0.2,1]))
			gl.drawElements(gl.TRIANGLES, 24, gl.UNSIGNED_SHORT, 0);
			
			gl.uniform1f(useConstColorID, 0.0)
			
			//set back to identity
			gl.uniformMatrix4fv(uModelMatrixID, false, new Matrix4().elements)
		}
}

//A particle system is "renderable", meaning it takes gl context as input and provides a draw function
var ParticleSystem = function(glContext){
	this.gl = glContext
	
	this.particleBufferSize = 100000 //starting size of buffer
	this.numParticles = 0 //0 particles to start out
	this.particleBuffers = {//all buffers start as null
		ps0      : null,
		ps0dot   : null,
		ps1      : null,
		ps1dot   : null,
		psMid    : null,
		psMidDot : null,
	}
	this.ps0BufferID
	this.ps1BufferID
	
	this.activeParticleBuffer
	this.activeDotBuffer
	this.activeParticleBufferID
	
	this.nonActiveParticleBuffer
	this.nonActiveDotBuffer
	this.nonActiveParticleBufferID
	
	this.forceBufferSize = 1000 //starting size of buffer
	this.numForces = 0 //0 forces to start out
	this.forceBuffer 
	
	this.wallBufferSize = 30 //starting size of buffer
	this.numWalls = 0 //0 walls to start out
	this.wallBuffer
	
	//this is a list of objects in the scene that have a draw call
	this.drawAbles = []
	
	//an enumeration
	this.particle_vars = {
		PARTXPOS     : 0,  //  position    
		PARTYPOS     : 1,
		PARTZPOS     : 2,
		PARTXVEL     : 3, //  velocity    
		PARTYVEL     : 4,
		PARTZVEL     : 5,
		PARTXFTOT   : 6,  // force accumulator:'ApplyForces()' fcn clears
		PARTYFTOT   : 7,  // to zero, then adds each force to each particle.
		PARTZFTOT   : 8,        
		PARTR        : 9,  // color : red,green,blue
		PARTG        :10,  
		PARTB        :11,
		PARTMASS     :12,  // mass   
		PARTDIAM 	  :13,	// on-screen diameter (in pixels)
		PARTRENDMODE :14,	// on-screen appearance (square, round, or soft-round)
		PARTAGE      :15,  // # of frame-times since creation/initialization
		PARTCHARGE   :16,  // for electrostatic repulsion/attraction
		PARTMASSVEL :17,  // time-rate-of-change of mass.
		PARTMASSFTOT:18,  // force-accumulator for mass-change
		
		PARTRVEL       :19,  // color : red,green,blue
		PARTGVEL       :20,  
		PARTBVEL       :21,
		
		PARTDISAPPEARAGE:22, //the age the particle disappears
		
		ISBOIDPARTICLE:23, //1 means it is a boid particle
		
		PARTICLESTRIDE:24,  // Size of array in CPart uses to store its values.
	}
	this.affected_particle_set = {
		ALL:0,
		PARTINDEX1:1,
		BOTH12:2,
	}
	this.wall_vars= {
		wall_types: {
			WTYPEDEAD       :0,   // not in use
			WTYPEBOXIN		 :1,
			WTYPEBOXOUT     :2,
			WTYPESPHERE     :3,  // solid sphere centered at particle with index e0;
			// no other particles allowed closer than 'radmin'
			// to the e0 particle.
			// (NOTE: e0 is a state-vector index: pS0[e0] )
			
			WTYPESTICK      :4,  // Connects 2 particles with fixed-length separation
			// between particles whose indices are held in e0,e1
			// (e.g. particles at pS0[e0] and pS0[e1] )
			WTYPEPULLEY     :5,  // Keep constant sum-of-distances for 3 particles
			// A,B,Pivot:  ||A-Pivot||+||B-Pivot|| = dmax.
			WTYPEANCHOR     :6,  // Lock one particle at location xpos,ypos,zpos
		},
		TYPE:0, //one of the "wall_types" from above
		KBOUNCY:1,//how bouncy is this wall
		WALLXPOS:2,
		WALLYPOS:3,
		WALLZPOS:4,
		RADIUS:5,
		AFFECTEDPARTICLES:6,//instance of "affected particle set"
		WPARTINDEX1:7,		 //index of particle affected by constraint
		WPARTINDEX2:8,
		
		WALLSTRIDE:9, //stride of a wall object
	}
	this.force_vars = {
		force_types: {
			FNONE      :0,       // Non-existent force: ignore this CForcer object
			FMOUSE     :1,       // Spring-like connection to the mouse cursor; lets
			// you 'grab' and 'wiggle' one particle(or several).
			FGRAVE    :2,       // Earth-gravity: pulls all particles 'downward'.
			FGRAVP    :3,       // Planetary-gravity; particle-pair (e0,e1) attract
			// each other with force== grav* mass0*mass1/ dist^2
			FWIND      :4,       // Blowing-wind-like force-field;fcn of 3D position
			FBUBBLE    :5,       // Constant inward force towards centerpoint if
			// particle is > max_radius away from centerpoint.
			FDRAG      :6,       // Viscous drag -- proportional to neg. velocity.
			FSPRING    :7,       // ties together 2 particles; distance sets force
			FSPRINGSET :8,       // a big collection of identical springs; lets you
			// make cloth & rubbery shapes as one force-making
			// object, instead of many many F_SPRING objects.
			FCHARGE    :9,       // attract/repel by charge and inverse distance;
			// applies to all charged particles.
			FBOID		:10, //only effects boid particles
		},
		TYPE:0,//one of the force_types from above
		POSX:1,
		POSY:2,
		POSZ:3,
		DIRX:4,
		DIRY:5,
		DIRZ:6,
		STRENGTH:7,
		RESTSTRENGTH:8,// Less than this treat as strength zero
		AFFECTEDPARTICLES:9,//type "affected particle set"
		PARTINDEX1:10,
		PARTINDEX2:11,
		
		FRADIUS:12, //used to find the radius of the wind which is a cylinder
		
		FORCESTRIDE:13,
	}
	this.initBuffers = function(){
		this.forceBuffer = new Float32Array(this.forceBufferSize * this.force_vars.FORCESTRIDE)
		this.wallBuffer = new Float32Array(this.wallBufferSize * this.wall_vars.WALLSTRIDE)
	
		for(key in this.particleBuffers){
			this.particleBuffers[key] = new Float32Array(this.particleBufferSize * this.particle_vars.PARTICLESTRIDE);
		}
		
		this.ps0BufferID = gl.createBuffer()
		this.ps1BufferID = gl.createBuffer()
		
		this.activeParticleBuffer = this.particleBuffers.ps0
		this.activeDotBuffer = this.particleBuffers.ps0dot
		this.activeParticleBufferID = this.ps0BufferID
		
		this.nonActiveParticleBuffer = this.particleBuffers.ps1
		this.nonActiveDotBuffer = this.particleBuffers.ps1dot
		this.nonActiveParticleBufferID = this.ps1BufferID
		
		gl.bindBuffer(gl.ARRAY_BUFFER, this.ps0BufferID);
		gl.bufferData(gl.ARRAY_BUFFER, this.particleBuffers.ps0, gl.DYNAMIC_DRAW);
	}
	//example addForce({TYPE:F_GRAV_E, AFECTED_PARTICLES: ALL}
	this.addForce = function( array_literal ){
		this.numForces += 1
		if(this.numForces > this.forceBufferSize){
			alert("cannot add more forces. need to implement buffer resizing")
			return
		}
		
		//current force index
		var i = (this.numForces-1) * this.force_vars.FORCESTRIDE
		
		//iterate through array_literal and add to buffer
		for(key in array_literal){
		
			//get value
			var value = array_literal[key]
			if(key == "TYPE")//special case since type must be converted to int
				value = this.force_vars.force_types[value]
			if(key == "AFFECTEDPARTICLES")
				value = this.affected_particle_set[value]
		
			//set value
			var var_offset = this.force_vars[key]
			this.forceBuffer[i + var_offset] =  value
		}
			
	
	}
	var boidForceExists = false
	var boidPartIndexStart
	var boidPartIndexEnd
	this.addBoidFlock = function(x,y,z,numBoids){
		//add boid force
		if(!boidForceExists)
			boidPartIndexStart = this.addForce({
				TYPE:"FBOID", 
			})
		
		boidPartIndexStart = this.numParticles
		boidPartIndexEnd = boidPartIndexStart + numBoids
		//add boid particles
		while(numBoids--){
			this.addParticle({
				"PARTXPOS":x + (Math.random()*.9),
				"PARTYPOS":y + (Math.random()*.9),
				"PARTZPOS":z + (Math.random()*.9),
				"PARTMASS":1,
				"PARTR":1,
				"PARTG":1,
				"PARTB":1,
				"ISBOIDPARTICLE":1,
				})
			}
		}
	//example addForce({TYPE:F_GRAV_E, AFECTED_PARTICLES: ALL}
	this.addWall = function( array_literal ){
		this.numWalls += 1
		if(this.numWalls > this.wallBufferSize){
			alert("cannot add more walls. need to implement buffer resizing")
			return
		}
		
		//current force index
		var i = (this.numWalls-1) * this.wall_vars.WALLSTRIDE
		
		//iterate through array_literal and add to buffer
		for(key in array_literal){
		
			//get value
			var value = array_literal[key]
			if(key == "TYPE")//special case since type must be converted to int
				value = this.wall_vars.wall_types[value]
			if(key == "AFFECTEDPARTICLES")
				value = this.affected_particle_set[value]
		
			//set value
			var var_offset = this.wall_vars[key]
			this.wallBuffer[i + var_offset] =  value
		}
	}
	this.addParticle = function( array_literal ){
		this.numParticles += 1
		if(this.numParticles >= this.particlesBufferSize){
			alert("cannot add more Particles. need to implement buffer resizing")
			return
		}
		
		//current force index
		var i = (this.numParticles-1) * this.particle_vars.PARTICLESTRIDE
		
		//iterate through array_literal and add to buffer
		for(key in array_literal){
			//set value
			var var_offset = this.particle_vars[key]
			this.activeParticleBuffer[i + var_offset] =  array_literal[key]
		}
		return this.numParticles-1
	}
	this.addBoxIn= function(x,y,z,length){
		this.addWall({
			'TYPE':'WTYPEBOXIN',
			'KBOUNCY':0.95,
			'WALLXPOS':x,
			'WALLYPOS':y,
			'WALLZPOS':z,
			'RADIUS':length,
			'AFFECTEDPARTICLES':"ALL"
		})
	}
	this.addBoxOut= function(x,y,z,length){
	
		this.drawAbles.push(new Box(x,y,z,length))
	
		this.addWall({
			TYPE:"WTYPEBOXOUT",
			KBOUNCY:0.8,
			WALLXPOS:x,
			WALLYPOS:y,
			WALLZPOS:z,
			RADIUS:length,
			AFFECTEDPARTICLES:"ALL"
		})
	}
	this.addSphere = function(x,y,z,radius){
	
		this.drawAbles.push(new Box(x,y,z,radius))
	
		this.addWall({
			TYPE:"WTYPESPHERE",
			KBOUNCY:0.5,
			WALLXPOS:x,
			WALLYPOS:y,
			WALLZPOS:z,
			RADIUS:radius,
			AFFECTED_PARTICLES:"ALL"
		})
	
	}
	this.addGravity = function(strength){
		this.addForce({
			TYPE:"FGRAVE", 
			AFECTED_PARTICLES: "ALL",
		})
	}
	this.addCharge = function(x,y,z,strength){
	
		this.addForce({
			TYPE:"FCHARGE",
			STRENGTH:strength,
			POSX:x,
			POSY:y,
			POSZ:z,
			AFECTED_PARTICLES: "ALL",
		})
	
	}
	this.shootParticle = function(xp,yp){
  
		// Convert to Canonical View Volume (CVV) coordinates too:
		var x = (xp - canvas.width/2)  / (canvas.width/2);			// normalize canvas to -1 <= x < +1,
		var y = (yp - canvas.height/2) / (canvas.height/2);
	
		var proj = rend.cam0.projectionMatrix()
		var view = rend.cam0.viewMatrix()
		var projView = proj.multiply(view)
		
		var inv = new Matrix4().setInverseOf(projView)
		
		var clickCoord = inv.multiplyVector4( new Vector4([x,y,0.8,1.0]) )
		var xdir = (clickCoord.elements[0]/ clickCoord.elements[3]) - rend.cam0.eye.x()
		var ydir = (clickCoord.elements[1]/ clickCoord.elements[3]) - rend.cam0.eye.y()
		var zdir = (clickCoord.elements[2]/ clickCoord.elements[3]) - rend.cam0.eye.z()
		
		this.addParticle({
			"PARTXPOS":rend.cam0.eye.x(),
			"PARTYPOS":rend.cam0.eye.y(),
			"PARTZPOS":rend.cam0.eye.z(),
			"PARTXVEL": xdir,
			"PARTYVEL": ydir,
			"PARTZVEL": zdir,
			"PARTR":Math.random(),
			"PARTG":Math.random(),
			"PARTB":Math.random(),
			"PARTDISAPPEARAGE":900,
			"PARTMASS": 1,
		})
	}
	this.getForceVar = function(i,var_name){
		return this.forceBuffer[ (i * this.force_vars.FORCESTRIDE) + this.force_vars[var_name] ]
	}
	this.getWallVar = function(i,var_name){
		return this.wallBuffer[ (i * this.wall_vars.WALLSTRIDE) + this.wall_vars[var_name] ]
	}
	this.getParticleVar = function(i, buffer,var_name){
		return buffer[ (i * this.particle_vars.PARTICLESTRIDE) + this.particle_vars[var_name] ]
	}
	this.setParticleVar = function(i, buffer, var_name, value){
		buffer[ (i * this.particle_vars.PARTICLESTRIDE) + this.particle_vars[var_name] ] = value
	}
	//takes a vector3 - adds it to the force acc
	this.applyVecForceToParticle = function(p, buffer, vec3){
		//get current forces
		var xftot = this.getParticleVar(p, buffer, "PARTXFTOT")
		var yftot = this.getParticleVar(p, buffer, "PARTYFTOT")
		var zftot = this.getParticleVar(p, buffer, "PARTZFTOT")
		
		//set forces
		var e = vec3.elements
		this.setParticleVar(p,buffer, "PARTXFTOT", xftot + e[0])
		this.setParticleVar(p,buffer, "PARTYFTOT", yftot + e[1])
		this.setParticleVar(p,buffer, "PARTZFTOT", zftot + e[2])
	}
	this.applyBoidSeperationForce = function(buffer, timestep){
		for(var p = boidPartIndexStart; p < boidPartIndexEnd; p++){
			var desiredSeperation = .2
			var steer = new Vector3([0,0,0])
			var myLocation = this.particlePosVector(p,buffer)
			var myVelocity = this.particleVelVector(p,buffer)
			for(var other = boidPartIndexStart; other < boidPartIndexEnd; other++) {
				var otherLocation = this.particlePosVector(other, buffer)
				var dist = myLocation.dist(otherLocation)
				
				if ((dist > 0) && (dist < desiredSeperation)) {
					// Calculate vector pointing away from neighbor
					var diff = new Vector3().sub(myLocation, otherLocation);
					steer.add(diff);
			  }
			}
			if(steer.length > .1)
				steer.setLength(.1)
			this.applyVecForceToParticle(p,buffer,steer.scale(1))
		}
	}
	this.applyBoidAlignForce = function(buffer, timestep){
	  for(var p = boidPartIndexStart; p < boidPartIndexEnd; p++){
			var neighbordist = 1.5;
			var myLocation = this.particlePosVector(p,buffer)
			var myVelocity = this.particleVelVector(p,buffer)
			
			var sum = new Vector3(0, 0, 0);
			var count = 0;
			
			for(var other = boidPartIndexStart; other < boidPartIndexEnd; other++) {
			
				var otherLocation = this.particlePosVector(other,buffer)
				var otherVelocity = this.particleVelVector(other,buffer)
				var dist = myLocation.dist(otherLocation)
				  if ((dist > 0) && (dist < neighbordist)) {
					sum.add(otherVelocity);
					count++;
				  }
			}
			if (count > 0) {
			  sum.scale( 1 / count);
			  var steer = new Vector3().sub(sum, myVelocity)
			  if(steer.length > .3)
				steer.setLength(.3)
			  this.applyVecForceToParticle(p,buffer,steer.scale(3))
			}
		}
	}
	var lastBoidDir = new Vector3(Math.random(),Math.random(),Math.random())
	var boidCounter = 0
	this.applyBoidTarget = function(buffer, timestep){
	  if(boidCounter = 30){
			counter = 0
			lastBoidDir = new Vector3(Math.random(),Math.random(),Math.random())
	  }
	  for(var p = boidPartIndexStart; p < boidPartIndexEnd; p++){
			this.applyVecForceToParticle(p,buffer,lastBoidDir.scale(3))	
		}
	}
	//steer towards average location of neighborhood
	this.applyBoidCohesionForce = function(buffer, timestep){
		for(var p = boidPartIndexStart; p < boidPartIndexEnd; p++){
			var neighbordist = .3;
			var myLocation = this.particlePosVector(p,buffer)
			var myVelocity = this.particleVelVector(p,buffer)
			
			var sum = new Vector3(0, 0, 0);
			var count = 0;
			
			for(var other = boidPartIndexStart; other < boidPartIndexEnd; other++) {
				var otherLocation = this.particlePosVector(other,buffer)
				var otherVelocity = this.particleVelVector(other,buffer)
				var dist = myLocation.dist(otherLocation)

			    if ((dist > 0) && (dist < neighbordist)) {
					sum.add(otherLocation); // Add location
					count++;
			    }
			}
			if (count > 0) {
				sum.scale(1/count);//average location
				var steer = new Vector3().sub(sum, myLocation)
				if(steer.length > .1)
					steer.setLength(.1)
				this.applyVecForceToParticle(p,buffer,steer.scale(.8))
			 }
		}
	
	}
	this.applyAllForces = function(buffer, timestep){
		//first clear all particles FTOT to ZERO
		for(var p = 0; p < this.numParticles; p++){
			this.setParticleVar(p,buffer,"PARTXFTOT", 0)
			this.setParticleVar(p,buffer,"PARTYFTOT", 0)
			this.setParticleVar(p,buffer,"PARTZFTOT", 0)
		}
		//now accumulate forces
		for(var i = 0; i < this.numForces; i++){
		
			var force_type = this.getForceVar(i,"TYPE")
			switch(force_type){
				case 10://FBOID
					this.applyBoidSeperationForce(buffer,timestep)
					this.applyBoidAlignForce(buffer,timestep)
					this.applyBoidCohesionForce(buffer,timestep)
					break
				case 2://FGRAVE
					for(var p = 0; p < this.numParticles; p++){
						//BOIDS particles not affected by gravity in my model
						if(this.getParticleVar(p,buffer, "ISBOIDPARTICLE")!=1){
							var ytot = this.getParticleVar(p, buffer, "PARTYFTOT")
							this.setParticleVar(p, buffer, "PARTYFTOT", ytot - (0.06 * timestep))
						}
					}
					break
				case 7://spring
					var partInd1 = this.getForceVar(i,"PARTINDEX1")
					var partInd2 = this.getForceVar(i,"PARTINDEX2")
					var stren = this.getForceVar(i,"STRENGTH")
					
					var pos1 = this.particlePosVector(partInd1,buffer)
					var pos2 = this.particlePosVector(partInd2,buffer)
					
					var dist = pos1.dist(pos2)
					var force= dist * stren
					
					var dir1 = new Vector3().sub(pos2, pos1)
					var dir2 = new Vector3().sub(pos1, pos2)
					
					this.applyVecForceToParticle(partInd1,buffer, dir1.scale(1/30))
					this.applyVecForceToParticle(partInd2,buffer, dir2.scale(1/30))
					
					break
				case 9://charge
					for(var p = 0; p < this.numParticles; p++){
						//charge pos
						var chargeX = this.getForceVar(i,"POSX")
						var chargeY = this.getForceVar(i,"POSY")
						var chargeZ = this.getForceVar(i,"POSZ")
						//part pos
						var x = this.getParticleVar(p,buffer, "PARTXPOS")
						var y = this.getParticleVar(p,buffer, "PARTYPOS")
						var z = this.getParticleVar(p,buffer, "PARTZPOS")
						
						//calc force
						var dist = utils.distanceBetweenPoints(x,y,z,chargeX,chargeY,chargeZ)
						var force = 0.08 / (dist + .000001)
						var direction = new Vector3([x - chargeX, y - chargeY, z - chargeZ]).normalize()
						
						var xForce = force * direction.x()
						var yForce = force * direction.y()
						var zForce = force * direction.z()
						
						
						//get current forces
						var xftot = this.getParticleVar(p, buffer, "PARTXFTOT")
						var yftot = this.getParticleVar(p, buffer, "PARTYFTOT")
						var zftot = this.getParticleVar(p, buffer, "PARTZFTOT")
						//set forces
						this.setParticleVar(p,buffer, "PARTXFTOT", xftot + xForce)
						this.setParticleVar(p,buffer, "PARTYFTOT", yftot + yForce)
						this.setParticleVar(p,buffer, "PARTZFTOT", zftot + zForce)
					}
					break
				case 4://fwind
					for(var p = 0; p < this.numParticles; p++){
						var fpos = this.forcePosVector(i)
						var fdir = this.forceDirVector(i)
						var radius =  this.getForceVar(i,"FRADIUS")
						var strength = this.getForceVar(i,"STRENGTH")
						
						var ppos = this.particlePosVector(p,buffer)
						var page = this.getParticleVar(p, buffer, "PARTAGE")//age is a simpler stand in for constant mass decay
						
						if(ppos.dist(fpos) < radius){
							this.applyVecForceToParticle(p,buffer,fdir.scale(strength).scale((page*1.5)/180))
						}
					}
					break
			}
		}
	
	}
	this.applyAllWalls = function(buffer){
		for(var i = 0; i < this.numWalls; i++){
		
			var wall_type = this.getWallVar(i,"TYPE")
			switch(wall_type){
				case 1://BOX IN
					for(var p = 0; p < this.numParticles; p++){
						var xpos = this.getParticleVar(p,buffer, "PARTXPOS")
						var ypos = this.getParticleVar(p,buffer, "PARTYPOS")
						var zpos = this.getParticleVar(p,buffer, "PARTZPOS")
						var xvel = this.getParticleVar(p,buffer, "PARTXVEL")
						var yvel = this.getParticleVar(p,buffer, "PARTYVEL")
						var zvel = this.getParticleVar(p,buffer, "PARTZVEL")
						
						var boxX = this.getWallVar(i,"WALLXPOS")
						var boxY = this.getWallVar(i,"WALLYPOS")
						var boxZ = this.getWallVar(i,"WALLZPOS")
						
						var rad = this.getWallVar(i,"RADIUS")
						
						var kbounce = this.getWallVar(i,"KBOUNCY")
						
						//reverse x
						if(xpos > boxX + rad ){
							this.setParticleVar(p,buffer,"PARTXPOS", boxX + rad )
							this.setParticleVar(p,buffer,"PARTXVEL", xvel * -1 * kbounce)
						}
						if( xpos < boxX - rad){
							this.setParticleVar(p,buffer,"PARTXPOS", boxX - rad )
							this.setParticleVar(p,buffer,"PARTXVEL", xvel * -1 * kbounce)
						}
						
						//reverse y
						if(ypos > boxY + rad ){
							this.setParticleVar(p,buffer,"PARTYPOS", boxY + rad )
							this.setParticleVar(p,buffer,"PARTYVEL", yvel * -1 * kbounce)
						}
						if( ypos < boxY - rad){
							this.setParticleVar(p,buffer,"PARTYPOS", boxY - rad )
							this.setParticleVar(p,buffer,"PARTYVEL", yvel * -1 * kbounce)
						}
						
						//reverse z
						if(zpos > boxZ + rad ){
							this.setParticleVar(p,buffer,"PARTZPOS", boxZ + rad )
							this.setParticleVar(p,buffer,"PARTZVEL", zvel * -1* kbounce)
						}
						if(zpos < boxZ - rad){
							this.setParticleVar(p,buffer,"PARTZPOS", boxZ - rad )
							this.setParticleVar(p,buffer,"PARTZVEL", zvel * -1* kbounce)
						}
						
					}
					break;
				case 2://BOX OUT
					for(var p = 0; p < this.numParticles; p++){
						var xpos = this.getParticleVar(p, buffer, "PARTXPOS")
						var ypos = this.getParticleVar(p, buffer, "PARTYPOS")
						var zpos = this.getParticleVar(p, buffer, "PARTZPOS")
						var xvel = this.getParticleVar(p, buffer, "PARTXVEL")
						var yvel = this.getParticleVar(p, buffer, "PARTYVEL")
						var zvel = this.getParticleVar(p, buffer, "PARTZVEL")
						
						var boxX = this.getWallVar(i,"WALLXPOS")
						var boxY = this.getWallVar(i,"WALLYPOS")
						var boxZ = this.getWallVar(i,"WALLZPOS")
						
						var rad = this.getWallVar(i,"RADIUS")
						var kbounce = this.getWallVar(i,"KBOUNCY")
						
						var insideBox = false
						if( zpos < (boxZ + rad) && 
							xpos < (boxX + rad) &&
							xpos > (boxX - rad) &&
							ypos < (boxY + rad) &&
							ypos > (boxY - rad) &&
							
							zpos > (boxZ - rad)){
							insideBox = true
							//did not implement correct reflections off boxes
							 this.setParticleVar(p,buffer,"PARTXVEL", xvel * -1.1)
							 this.setParticleVar(p,buffer,"PARTYVEL", yvel * -1.1)
							 this.setParticleVar(p,buffer,"PARTZVEL", zvel * -1.1)
							}
						
					}
					break
				case 3://SPHERE
					for(var p = 0; p < this.numParticles; p++){
						var ppos = this.particlePosVector(p,buffer)
						var wpos = this.wallPosVector(i,buffer)
						
						var xvel = this.getParticleVar(p, buffer, "PARTXVEL")
						var yvel = this.getParticleVar(p, buffer, "PARTYVEL")
						var zvel = this.getParticleVar(p, buffer, "PARTZVEL")
						
						if(ppos.dist(wpos) < this.getWallVar(i, "RADIUS")){
							 
							 this.setParticleVar(p,buffer,"PARTXVEL", xvel * -1.1)
							 this.setParticleVar(p,buffer,"PARTYVEL", yvel * -1.1)
							 this.setParticleVar(p,buffer,"PARTZVEL", zvel * -1.1)
							 
						}
					}
					break
				case 6://anchor
					var p = this.getWallVar(i,"WPARTINDEX1")
					var x = this.getWallVar(i,"WALLXPOS")
					var y = this.getWallVar(i,"WALLYPOS")
					var z = this.getWallVar(i,"WALLZPOS")
				
					this.setParticleVar(p,buffer,"PARTXPOS", x)
					this.setParticleVar(p,buffer,"PARTYPOS", y)
					this.setParticleVar(p,buffer,"PARTZPOS", z)
			}
		
		}
	
	}
	this.dotMaker = function(part_buffer, dot_buffer){
		for(var i = 0; i < this.numParticles; i++){
			//copy over velocities
			var xvel = this.getParticleVar(i,part_buffer,"PARTXVEL")
			var yvel = this.getParticleVar(i,part_buffer,"PARTYVEL")
			var zvel = this.getParticleVar(i,part_buffer,"PARTZVEL")
			this.setParticleVar(i,dot_buffer,"PARTXPOS", xvel)
			this.setParticleVar(i,dot_buffer,"PARTYPOS", yvel)
			this.setParticleVar(i,dot_buffer,"PARTZPOS", zvel)
			
			//compute and set velocities
			var mass = this.getParticleVar(i,part_buffer,"PARTMASS")
			var ftotx = this.getParticleVar(i,part_buffer,"PARTXFTOT")
			var ftoty = this.getParticleVar(i,part_buffer,"PARTYFTOT")
			var ftotz = this.getParticleVar(i,part_buffer,"PARTZFTOT")
			var accx = ftotx / mass
			var accy = ftoty / mass
			var accz = ftotz / mass
			
			this.setParticleVar(i,dot_buffer,"PARTXVEL", accx)
			this.setParticleVar(i,dot_buffer,"PARTYVEL", accy)
			this.setParticleVar(i,dot_buffer,"PARTZVEL", accz)
			
			
			//do color shifts
			var rvel = this.getParticleVar(i,part_buffer,"PARTRVEL")
			var gvel = this.getParticleVar(i,part_buffer,"PARTGVEL")
			var bvel = this.getParticleVar(i,part_buffer,"PARTBVEL")
			
			this.setParticleVar(i,dot_buffer,"PARTR", rvel)
			this.setParticleVar(i,dot_buffer,"PARTG", gvel)
			this.setParticleVar(i,dot_buffer,"PARTB", bvel)
			
			//age
			this.setParticleVar(i,dot_buffer,"PARTAGE", 1)
	
		}
	
	}
	this.solvers = {
			//s1 = s0 + h*s0dot	
			"explicit_euler": function(non_active_part_buffer, part_buffer, dot_buffer , timestep){
					for(var i = 0; i < this.numParticles; i++){
					
						//part
						var partx = this.getParticleVar(i,part_buffer, "PARTXPOS")
						var party = this.getParticleVar(i,part_buffer, "PARTYPOS")
						var partz = this.getParticleVar(i,part_buffer, "PARTZPOS")
						
						var partxvel = this.getParticleVar(i,part_buffer, "PARTXVEL")
						var partyvel = this.getParticleVar(i,part_buffer, "PARTYVEL")
						var partzvel = this.getParticleVar(i,part_buffer, "PARTZVEL")
						
						var partr = this.getParticleVar(i,part_buffer, "PARTR")
						var partg = this.getParticleVar(i,part_buffer, "PARTG")
						var partb = this.getParticleVar(i,part_buffer, "PARTB")
						
						var partage = this.getParticleVar(i,part_buffer, "PARTAGE")
						
						//dot
						var dotx = this.getParticleVar(i,dot_buffer, "PARTXPOS")
						var doty = this.getParticleVar(i,dot_buffer, "PARTYPOS")
						var dotz = this.getParticleVar(i,dot_buffer, "PARTZPOS")
						
						var dotxvel = this.getParticleVar(i,dot_buffer, "PARTXVEL")
						var dotyvel = this.getParticleVar(i,dot_buffer, "PARTYVEL")
						var dotzvel = this.getParticleVar(i,dot_buffer, "PARTZVEL")
						
						var dotr = this.getParticleVar(i,dot_buffer, "PARTR")
						var dotg = this.getParticleVar(i,dot_buffer, "PARTG")
						var dotb = this.getParticleVar(i,dot_buffer, "PARTB")
						
						
						//add
						this.setParticleVar(i,part_buffer,"PARTXPOS", partx + (dotx * timestep))
						this.setParticleVar(i,part_buffer,"PARTYPOS", party + (doty * timestep))
						this.setParticleVar(i,part_buffer,"PARTZPOS", partz + (dotz * timestep))
			
						this.setParticleVar(i,part_buffer,"PARTXVEL", partxvel + (dotxvel * timestep))
						this.setParticleVar(i,part_buffer,"PARTYVEL", partyvel + (dotyvel * timestep))
						this.setParticleVar(i,part_buffer,"PARTZVEL", partzvel + (dotzvel * timestep))
						
						this.setParticleVar(i,part_buffer,"PARTR", partr + (dotr * timestep))
						this.setParticleVar(i,part_buffer,"PARTG", partg + (dotg * timestep))
						this.setParticleVar(i,part_buffer,"PARTB", partb + (dotb * timestep))
						
						this.setParticleVar(i,part_buffer,"PARTAGE", partage + 1)
						
					}
			},
		
		}
	this.solve
	this.swapBuffers = function(){
	
		var temp	 = this.activeParticleBuffer
		var tempdot  = this.activeDotBuffer
		var tempID	 = this.activeParticleBufferID
	
		this.activeParticleBuffer = this.nonActiveParticleBuffer
		this.activeDotBuffer = this.nonActiveDotBuffer
		this.activeParticleBufferID = this.nonActiveParticleBufferID
		
		this.nonActiveParticleBuffer = temp
		this.nonActiveDotBuffer = tempdot
		this.nonActiveParticleBufferID = tempID
	
	}
	this.particlePosVector = function(i,buffer){
		var x =  this.getParticleVar(i,buffer,"PARTXPOS")
		var y =  this.getParticleVar(i,buffer,"PARTYPOS")
		var z =  this.getParticleVar(i,buffer,"PARTZPOS")
		return new Vector3([x,y,z])
	}
	this.wallPosVector = function(i,buffer){
		var x =  this.getWallVar(i,buffer,"WALLXPOS")
		var y =  this.getWallVar(i,buffer,"WALLYPOS")
		var z =  this.getWallVar(i,buffer,"WALLZPOS")
		return new Vector3([x,y,z])
	}
	this.particleVelVector = function(i,buffer){
		var xvel =  this.getParticleVar(i,buffer,"PARTXVEL")
		var yvel =  this.getParticleVar(i,buffer,"PARTYVEL")
		var zvel =  this.getParticleVar(i,buffer,"PARTZVEL")
		return new Vector3([xvel,yvel,zvel])
	}
	this.forcePosVector = function(i){
		var x =  this.getForceVar(i,"POSX")
		var y =  this.getForceVar(i,"POSY")
		var z =  this.getForceVar(i,"POSX")
		return new Vector3([x,y,z])
	}
	this.forceDirVector = function(i){
		var dirx =  this.getForceVar(i,"DIRX")
		var diry =  this.getForceVar(i,"DIRY")
		var dirz =  this.getForceVar(i,"DIRZ")
		return new Vector3([dirx,diry,dirz])
	}
	this.addWind = function(x,y,z,dirx,diry,dirz,radius){
		this.addForce({
				TYPE:"FWIND",
				POSX:x,
				POSY:y,
				POSZ:z,
				DIRX:dirx,
				DIRY:diry,
				DIRZ:dirz,
				FRADIUS:radius,
				STRENGTH:0.5,
			}
		)
	
	
	}
	var fireWindAdded = false
	this.fireOn = false
	this.animateFire = function(){
	
		var pos = new Vector3([0,0,0])
		var e = pos.elements
		if(! fireWindAdded){
			fireWindAdded = true
			this.addWind(e[0] ,e[1] ,e[2], 0,1,0, 1.1)
		}
	
		var particlesPerFrame = 30
		
		while(particlesPerFrame--){
		
			//multiplying Math.random * Math.random makes bigger nummbers less likely
			var rand = function(){
				return Math.random() - 0.5
			}
			
			var shiftAmount = new Vector3([rand() * rand(), 0 , rand() * rand()]).scale(1.5)
			var shiftedPos = pos.add(shiftAmount)
			
			var trajectory = new Vector3([rand(), 1.2, rand()]).scale(0.12)
			
			var p = shiftedPos.elements
			var t = trajectory.elements
			this.addParticle({
			
				"PARTXPOS":p[0],
				"PARTYPOS":p[1],
				"PARTZPOS":p[2],
				"PARTXVEL":t[0],
				"PARTYVEL":t[1],
				"PARTZVEL":t[2],
				"PARTR":1,
				"PARTG":1,
				"PARTB":1,
				"PARTRVEL":0,
				"PARTGVEL":-.07,
				"PARTBVEL":-.13,
				"PARTAGE":0,
				"PARTMASS": 1,
				"PARTDISAPPEARAGE":50,
			
			})
		}
	
	
	}
	this.addCloth = function(x,y,z){
		var seperation = 0.2
		var clothLenX = 10
		var clothLenY = 10
		var clothIndexStart = this.numParticles
		//add particles
		for(var row = 0; row < clothLenY; row++){
			for(var col = 0; col < clothLenY; col++){
				var p = this.addParticle({
					"PARTXPOS":x + (row * seperation),
					"PARTYPOS":y + (col * seperation),
					"PARTZPOS":z,
					"PARTR":.3,
					"PARTG":0,
					"PARTB":1,
					"PARTAGE":0,
					"PARTMASS": 1,
				})
			}
		}
		
		//add springs
		//link in X direction first, stop one before the end
		for(var row = 0; row < clothLenY -1; row++){
			for(var i = 0; i < clothLenX -1; i++){
				this.addForce({
					"TYPE":"FSPRING",
					"AFFECTEDPARTICLES":this.affected_particle_set.BOTH12,
					"PARTINDEX1": clothIndexStart + i + (row * clothLenX),
					"PARTINDEX2": clothIndexStart + i + 1 + (row * clothLenX),
					"STRENGTH":1,
				})
			}
		}
		//link in Y direction second
		for(var row = 0; row < clothLenX -1; row++){
			for(var i = 0; i < clothLenY -1; i++){
				this.addForce({
					"TYPE":"FSPRING",
					"AFFECTEDPARTICLES":this.affected_particle_set.BOTH12,
					"PARTINDEX1": clothIndexStart + i + (row * clothLenX),
					"PARTINDEX2": clothIndexStart + i + clothLenX + (row * clothLenX),
					"STRENGTH":1,
				})
			}
		}
		//anchors
		this.addWall({
				"TYPE":"WTYPEANCHOR",
				"WPARTINDEX1": clothIndexStart,
				"WALLXPOS":x,
				"WALLYPOS":y,
				"WALLZPOS":z,
		})
		this.addWall({
			"TYPE":"WTYPEANCHOR",
			"WPARTINDEX1": clothIndexStart + clothLenX,
			"WALLXPOS":x + (9 * seperation),
			"WALLYPOS":y,
			"WALLZPOS":z,
		})
		
	
	}
	this.draw = function(timestep){
		var timestep = 1/3 //constant timestep for now
		
		if(mouseDown)
			this.shootParticle(MouseX,MouseY)
			
		if(this.fireOn)
		this.animateFire()
	
		//apply all force
		this.applyAllForces(this.activeParticleBuffer, timestep)
	
		//call dot maker on active particle buffer
		this.dotMaker(this.activeParticleBuffer, this.activeDotBuffer)
	
	
		//render active Particle buffer
		gl.bindBuffer(gl.ARRAY_BUFFER, this.activeParticleBufferID);
		gl.bufferData(gl.ARRAY_BUFFER, this.activeParticleBuffer, gl.DYNAMIC_DRAW);
		//attributeID, size of vector, type, normalized?, stride, offset
		var stride = this.particle_vars.PARTICLESTRIDE * this.activeParticleBuffer.BYTES_PER_ELEMENT
		gl.vertexAttribPointer(a_PositionID,3,gl.FLOAT, false, stride,0)
		gl.vertexAttribPointer(a_ColorID,3,gl.FLOAT, false, stride,this.particle_vars.PARTR * 4)
		gl.enableVertexAttribArray(a_ColorID);
		gl.vertexAttribPointer(a_AgeID,3,gl.FLOAT, false, stride,this.particle_vars.PARTAGE * 4)
		gl.enableVertexAttribArray(a_AgeID);
		gl.vertexAttribPointer(disappear_ageID,3,gl.FLOAT, false, stride,this.particle_vars.PARTDISAPPEARAGE * 4)
		gl.enableVertexAttribArray(disappear_ageID);
		gl.drawArrays(gl.POINTS, 0, this.numParticles);
		gl.disableVertexAttribArray(disappear_ageID);
		
		
		//solver - find non-active s1 from s0 and s0dot
		this.solve = this.solvers["explicit_euler"]
		this.solve(this.nonActiveParticleBuffer, this.activeParticleBuffer, this.activeDotBuffer,timestep)

		//apply constraints
		this.applyAllWalls(this.activeParticleBuffer)
		
		//swap
		//this.swapBuffers()
		
		//draw other things
		for(i in this.drawAbles)
			this.drawAbles[i].draw()
		
	}


}

var utils =  {
	distanceBetweenPoints : function(x1,y1,z1,x2,y2,z2){
		var sqrd = Math.pow(x1-x2,2) + Math.pow(y1-y2,2) + Math.pow(z1-z2,2)
		return Math.sqrt(sqrd)
	
	},
	getShader : function(gl, elementId) {
		var shaderScript, theSource, currentChild, shader;

		var shaderScript = document.getElementById(elementId);
		var theSource = "";
		var currentChild = shaderScript.firstChild;

		while(currentChild) {
			if (currentChild.nodeType == currentChild.TEXT_NODE) {
				theSource += currentChild.textContent;
			}
			currentChild = currentChild.nextSibling;
		}
		
		if (shaderScript.type == "x-shader/x-fragment") {
			shader = gl.createShader(gl.FRAGMENT_SHADER);
		} else if (shaderScript.type == "x-shader/x-vertex") {
			shader = gl.createShader(gl.VERTEX_SHADER);
		} else {
			return null;
		}

		gl.shaderSource(shader, theSource);
		gl.compileShader(shader);  
		
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {  
			alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));  
			return null;  
		}
		
		return shader;
	},
	lastTime: 0,
	elapsedTime: function(sinceTime) {
		if (!lastTime)  lastTime = Date.now();
		return Date.now() - sinceTime;	
	},
};


var rend = new Renderer()
rend.start()



</script>
</body>
<body>
<canvas id="glcanvas" width="1024" height="768">
</canvas>

<script src="lib/webgl-utils.js"></script>
<script src="lib/webgl-debug.js"></script>
<script src="lib/cuon-utils.js"></script>
<script src="lib/cuon-matrix-quat.js"></script> 


<script id="fragmentShader" type="x-shader/x-fragment">
precision mediump float;

varying vec4 vColor;

void main(void) {
	gl_FragColor = vec4(1.0,1.0,1.0,1.0);
}
</script>

<script id="vertexShader" type="x-shader/x-vertex">
attribute vec3 a_Position;

uniform mat4 uViewMatrix;
uniform mat4 uProjMatrix;

varying vec4 vColor;

void main(void) {
	gl_Position = uProjMatrix * uViewMatrix * vec4(a_Position, 1.0);
	gl_PointSize = 10.0;
	vColor = vec4(1.0,1.0,1.0,1.0);
}
</script>


<script type="text/javascript">

//globals
var gl //context
var a_PositionID 
var a_ColorID 
var canvas //canvas element

var Renderer = function(){
	 var Camera = function(){
		//look down the z negative axis
		this.eye = new Vector3([0,4,4])
		this.at = new Vector3([0,3,-5])
		this.up = new Vector3([0,1,0])
		this.fovy  = 70
		this.aspect  = 1.0
		this.near = .01
		this.far  = 100
		
		this.pan = function(deg){
			this.at = new Matrix4().setRotate(-deg,this.up.x(),this.up.y(),this.up.z()).multiplyVector3(this.at)
		}
		this.tilt = function(deg){
			var crss = this.at.cross(this.up)//vec parrallel to both
			this.at = new Matrix4().setRotate(deg, crss.x(), crss.y(), crss.z()).multiplyVector3(this.at)
			this.up = new Matrix4().setRotate(deg, crss.x(), crss.y(), crss.z()).multiplyVector3(this.up)
		}
		this.roll = function(deg){
			this.up = new Matrix4().setRotate(deg,this.at.x(),this.at.y(),this.at.z()).multiplyVector3(this.up)
		}

		this.transX = function(unit){
			this.at.elements[0] = this.at.x() + unit
			this.eye.elements[0] = this.eye.x() + unit
		}
		this.transY = function(unit){
			this.at.elements[1] = this.at.y() + unit
			this.eye.elements[1] = this.eye.y() + unit
		}
		this.transZ = function(unit){
			this.at.elements[2] = this.at.z() + unit
			this.eye.elements[2] = this.eye.z() + unit
		}
		
		this.projectionMatrix = function(){
			return new Matrix4().setPerspective(this.fovy, this.aspect, this.near, this.far)
		}
		this.viewMatrix = function(){
			return new Matrix4().setLookAt(this.eye.x(), this.eye.y(), this.eye.z(), this.at.x(), this.at.y(), this.at.z(), this.up.x(), this.up.y(), this.up.z())
		}
		
		this.keyboardControl = function(ev){
			var speed = 2
			switch(ev.keyCode) {
				case 39://right arrow
					this.pan(speed);break
				case 37://left arrow
					this.pan(-speed);break
				case 38://up arrow
					this.tilt(speed);break
				case 40://down arrow
					this.tilt(-speed);break
				case 65://a
					this.transX(speed/40);break
				case 90://z
					this.transX(-speed/40);break
				case 83://s           
					this.transY(speed/40);break
				case 88://x           
					this.transY(-speed/40);break
				case 68://d           
					this.transZ(speed/40);break
				case 67://c           
					this.transZ(-speed/40);break
				case 70://f
					this.roll(speed);break
				case 86://v
					this.roll(-speed);break
			}
		
		}
		
	}
	this.cam0 = new Camera()
	this.uViewMatrixID
	this.uProjMatrixID 
	this.partSys
	this.ground_plane
	this.start = function(){
	
		//gl setup
		canvas = document.getElementById("glcanvas")
		gl = WebGLUtils.setupWebGL(canvas)

		gl.viewport(0,0,1024,768)
		gl.clearColor(0.0, 0.0, 0.0, 1.0)                     
		gl.enable(gl.DEPTH_TEST)                              
		gl.depthFunc(gl.LEQUAL)  

		//compile shaders
		var fragmentShader = utils.getShader(gl, "fragmentShader");
		var vertexShader = utils.getShader(gl, "vertexShader");
		
		// Create the shader program
		shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);

		// If creating the shader program failed, alert

		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			alert("Unable to initialize the shader program.");
		}

		gl.useProgram(shaderProgram);
		
		//position attribute
		a_PositionID = gl.getAttribLocation(shaderProgram, 'a_Position')
		if(a_PositionID < 0) console.log('Failed to get the gfx storage location of a_Position')
		gl.enableVertexAttribArray(a_PositionID);
		
		
		//projection matrix location
		uProjMatrixID = gl.getUniformLocation(shaderProgram, 'uProjMatrix')
		if(uProjMatrixID < 0) console.log('Failed to get the gfx storage location of uProjMatrix')
		
		//view matrix location
		uViewMatrixID = gl.getUniformLocation(shaderProgram, 'uViewMatrix')
		if(uViewMatrixID < 0) console.log('Failed to get the gfx storage location of uViewMatrix')
		
		//groundplane
		this.ground_plane = new GroundPlane(gl,"Y", 60, .2)
		this.ground_plane.init()
		
		//particle system
		this.partSys = new ParticleSystem(gl)
		this.partSys.initBuffers()
		
		//keyboard control
		window.addEventListener("keydown", this.cam0.keyboardControl.bind(this.cam0), false);
		
		//mouse control
		window.addEventListener("mousedown", this.partSys.shootParticleMouseHandler.bind(this.partSys), false);
		
		//add gravity
		this.partSys.addGravity()
		this.partSys.addBoxIn(0,6,0,6)
		
		window.requestAnimationFrame(this.draw.bind(this));
		
	}
	this.draw = function(){
		gl.clear(gl.COLOR_BUFFER_BIT)
		
		//set camera placement
		gl.uniformMatrix4fv(uProjMatrixID, false, this.cam0.projectionMatrix().elements)
		gl.uniformMatrix4fv(uViewMatrixID, false, this.cam0.viewMatrix().elements)
		
		this.ground_plane.draw()
		this.partSys.draw()
		
		window.requestAnimationFrame(this.draw.bind(this));
	}

}


//A ground plane is "renderable", meaning it takes gl context as input and provides a draw function
//axis == "X" "Y" or "Z" meaning x==0 y==0 or z==0
var GroundPlane = function(glContext, axis, num_lines, spacing){
	this.gl = glContext
	this.lineLength = 13
	this.vertexBuffer = new Float32Array(num_lines * 2 * 3 * 2 * 2)//2pts per line, 3 floats per point, 1 line horizontal, 1 vertical
	this.vertexBufferID
	this.init = function(){
		this.vertexBufferID = gl.createBuffer()
		if (!this.vertexBufferID) console.log('Failed to create tgorund plane vertex buffer');
		
		var start = -( spacing * (num_lines/2) )//the position the first line starts at
		var end = start * -1
		var i = 0
		for(var pos=start; pos <= (end*2); pos=pos+spacing){
			//extend down z
			this.vertexBuffer[i] = pos //X
			this.vertexBuffer[i+1] = 0 //Y
			this.vertexBuffer[i+2] = -(this.lineLength/2) //Z
			                   
			this.vertexBuffer[i+3] = pos //X
			this.vertexBuffer[i+4] = 0 //Y
			this.vertexBuffer[i+5] = (this.lineLength/2) //Z
			
			//extend down x
			this.vertexBuffer[i+6] = -(this.lineLength/2) //X
			this.vertexBuffer[i+7] = 0 //Y
			this.vertexBuffer[i+8] = pos //Z
			                    
			this.vertexBuffer[i+9] = (this.lineLength/2) //X
			this.vertexBuffer[i+10] = 0 //Y
			this.vertexBuffer[i+11] = pos //Z
			
			i = i + 12
		}
		console.log(this.vertexBuffer)
		
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBufferID);
		gl.bufferData(gl.ARRAY_BUFFER, this.vertexBuffer, gl.STATIC_DRAW);
		
		
	}
	this.draw = function(){
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBufferID);
		
		//attributeID, size of vector, type, normalized?, stride, offset
		gl.vertexAttribPointer(a_PositionID,3,gl.FLOAT, false, 0,0)
		
		gl.drawArrays(gl.LINES, 0, num_lines * 4);
	}


}

//A particle system is "renderable", meaning it takes gl context as input and provides a draw function
var ParticleSystem = function(glContext){
	this.gl = glContext
	
	this.particleBufferSize = 1000 //starting size of buffer
	this.numParticles = 0 //0 particles to start out
	this.particleBuffers = {//all buffers start as null
		ps0      : null,
		ps0dot   : null,
		ps1      : null,
		ps1dot   : null,
		psMid    : null,
		psMidDot : null,
	}
	this.ps0BufferID
	this.ps1BufferID
	this.activeParticleBuffer
	this.activeParticleBufferID
	
	this.forceBufferSize = 100 //starting size of buffer
	this.numForces = 0 //0 forces to start out
	this.forceBuffer 
	
	this.wallBufferSize = 30 //starting size of buffer
	this.numWalls = 0 //0 walls to start out
	this.wallBuffer
	
	//an enumeration
	this.particle_vars = {
		PARTXPOS     : 0,  //  position    
		PARTYPOS     : 1,
		PARTZPOS     : 2,
		PARTXVEL     : 3, //  velocity    
		PARTYVEL     : 4,
		PARTZVEL     : 5,
		PARTXFTOT   : 6,  // force accumulator:'ApplyForces()' fcn clears
		PARTYFTOT   : 7,  // to zero, then adds each force to each particle.
		PARTZFTOT   : 8,        
		PARTR        : 9,  // color : red,green,blue
		PARTG        :10,  
		PARTB        :11,
		PARTMASS     :12,  // mass   
		PARTDIAM 	  :13,	// on-screen diameter (in pixels)
		PARTRENDMODE :14,	// on-screen appearance (square, round, or soft-round)
		PARTAGE      :15,  // # of frame-times since creation/initialization
		PARTCHARGE   :16,  // for electrostatic repulsion/attraction
		PARTMASSVEL :17,  // time-rate-of-change of mass.
		PARTMASSFTOT:18,  // force-accumulator for mass-change
		
		PARTICLESTRIDE:19,  // Size of array in CPart uses to store its values.
	}
	this.affected_particle_set = {
		ALL:0,
		PARTINDEX1:1,
		BOTH12:2,
	}
	this.wall_vars= {
		wall_types: {
			WTYPEDEAD       :0,   // not in use
			WTYPEBOXIN		 :1,
			WTYPEBOXOUT     :2,
			WTYPESPHERE     :3,  // solid sphere centered at particle with index e0;
			// no other particles allowed closer than 'radmin'
			// to the e0 particle.
			// (NOTE: e0 is a state-vector index: pS0[e0] )
			
			WTYPESTICK      :4,  // Connects 2 particles with fixed-length separation
			// between particles whose indices are held in e0,e1
			// (e.g. particles at pS0[e0] and pS0[e1] )
			WTYPEPULLEY     :5,  // Keep constant sum-of-distances for 3 particles
			// A,B,Pivot:  ||A-Pivot||+||B-Pivot|| = dmax.
			WTYPEANCHOR     :6,  // Lock one particle at location xpos,ypos,zpos
		},
		TYPE:0, //one of the "wall_types" from above
		KBOUNCY:1,//how bouncy is this wall
		WALLXPOS:2,
		WALLYPOS:3,
		WALLZPOS:4,
		RADIUS:5,
		AFFECTEDPARTICLES:6,//instance of "affected particle set"
		PARTINDEX1:7,		 //index of particle affected by constraint
		PARTINDEX2:8,
		
		WALLSTRIDE:9, //stride of a wall object
	}
	this.force_vars = {
		force_types: {
			FNONE      :0,       // Non-existent force: ignore this CForcer object
			FMOUSE     :1,       // Spring-like connection to the mouse cursor; lets
			// you 'grab' and 'wiggle' one particle(or several).
			FGRAVE    :2,       // Earth-gravity: pulls all particles 'downward'.
			FGRAVP    :3,       // Planetary-gravity; particle-pair (e0,e1) attract
			// each other with force== grav* mass0*mass1/ dist^2
			FWIND      :4,       // Blowing-wind-like force-field;fcn of 3D position
			FBUBBLE    :5,       // Constant inward force towards centerpoint if
			// particle is > max_radius away from centerpoint.
			FDRAG      :6,       // Viscous drag -- proportional to neg. velocity.
			FSPRING    :7,       // ties together 2 particles; distance sets force
			FSPRINGSET :8,       // a big collection of identical springs; lets you
			// make cloth & rubbery shapes as one force-making
			// object, instead of many many F_SPRING objects.
			FCHARGE    :9,       // attract/repel by charge and inverse distance;
			// applies to all charged particles.
		},
		TYPE:0,//one of the force_types from above
		POSX:1,
		POSY:2,
		POSZ:3,
		DIRX:4,
		DIRY:5,
		DIRZ:6,
		STRENGTH:7,
		RESTSTRENGTH:8,// Less than this treat as strength zero
		AFFECTEDPARTICLES:9,//type "affected particle set"
		PARTINDEX1:10,
		PARTINDEX2:11,
		
		FORCESTRIDE:12,
	}
	this.initBuffers = function(){
		this.forceBuffer = new Float32Array(this.forceBufferSize * this.force_vars.FORCESTRIDE)
		this.wallBuffer = new Float32Array(this.wallBufferSize * this.wall_vars.WALLSTRIDE)
	
		for(key in this.particleBuffers){
			this.particleBuffers[key] = new Float32Array(this.particleBufferSize * this.particle_vars.PARTICLESTRIDE);
		}
		
		this.ps0BufferID = gl.createBuffer()
		this.ps1BufferID = gl.createBuffer()
		
		this.activeParticleBuffer = this.particleBuffers.ps0
		this.activeParticleBufferID = this.ps0BufferID
		
		gl.bindBuffer(gl.ARRAY_BUFFER, this.ps0BufferID);
		gl.bufferData(gl.ARRAY_BUFFER, this.particleBuffers.ps0, gl.DYNAMIC_DRAW);
	}
	//example addForce({TYPE:F_GRAV_E, AFECTED_PARTICLES: ALL}
	this.addForce = function( array_literal ){
		this.numForces += 1
		if(this.numForces > this.forceBufferSize){
			alert("cannot add more particles. need to implement buffer resizing")
			return
		}
		
		//current force index
		var i = (this.numForces-1) * this.force_vars.FORCESTRIDE
		
		//iterate through array_literal and add to buffer
		for(key in array_literal){
		
			//get value
			var value = array_literal[key]
			if(key == "TYPE")//special case since type must be converted to int
				value = this.force_vars.force_types[value]
			if(key == "AFFECTEDPARTICLES")
				value = this.affected_particle_set[value]
		
			//set value
			var var_offset = this.force_vars[key]
			this.forceBuffer[i + var_offset] =  value
		}
			
	
	}
	//example addForce({TYPE:F_GRAV_E, AFECTED_PARTICLES: ALL}
	this.addWall = function( array_literal ){
		this.numWalls += 1
		if(this.numWalls > this.wallBufferSize){
			alert("cannot add more walls. need to implement buffer resizing")
			return
		}
		
		//current force index
		var i = (this.numWalls-1) * this.wall_vars.WALLSTRIDE
		
		//iterate through array_literal and add to buffer
		for(key in array_literal){
		
			//get value
			var value = array_literal[key]
			if(key == "TYPE")//special case since type must be converted to int
				value = this.wall_vars.wall_types[value]
			if(key == "AFFECTEDPARTICLES")
				value = this.affected_particle_set[value]
		
			//set value
			var var_offset = this.wall_vars[key]
			this.wallBuffer[i + var_offset] =  value
		}
	}
	this.addParticle = function( array_literal ){
		this.numParticles += 1
		if(this.numParticles > this.particlesBufferSize){
			alert("cannot add more Particles. need to implement buffer resizing")
			return
		}
		
		//current force index
		var i = (this.numParticles-1) * this.particle_vars.PARTICLESTRIDE
		
		//iterate through array_literal and add to buffer
		for(key in array_literal){
			//set value
			var var_offset = this.particle_vars[key]
			this.activeParticleBuffer[i + var_offset] =  array_literal[key]
		}
	}
	this.addBoxIn= function(x,y,z,length){
		this.addWall({
			'TYPE':'WTYPEBOXIN',
			'KBOUNCY':0.8,
			'WALLXPOS':x,
			'WALLYPOS':y,
			'WALLZPOS':z,
			'RADIUS':length,
			'AFFECTEDPARTICLES':"ALL"
		})
	}
	this.addBoxOut= function(x,y,z,legth){
		this.addWall({
			TYPE:"WTYPEBOXOUT",
			KBOUNCY:0.8,
			WALLXPOS:x,
			WALLYPOS:y,
			WALLZPOS:z,
			RADIUS:length,
			AFFECTEDPARTICLES:"ALL"
		})
	}
	this.addSphere = function(x,y,x,radius){
		this.addWall({
			TYPE:"WTYPESPHERE",
			KBOUNCY:0.5,
			WALLXPOS:x,
			WALLYPOS:y,
			WALLZPOS:z,
			RADIUS:radius,
			AFFECTED_PARTICLES:"ALL"
		})
	
	}
	this.addGravity = function(strength){
		this.addForce({
			TYPE:"FGRAVE", 
			AFECTED_PARTICLES: "ALL",
		})
	}
	this.addWind = function(x,y,z,dirX,dirY,dirZ, strength){
	
	}
	this.addFlock = function(x,y,z){
	
	}
	this.shootParticleMouseHandler = function(ev){
	
		var rect = ev.target.getBoundingClientRect();	    // get canvas corners in pixels
		var xp = ev.clientX - rect.left;					//x==0 at canvas left edge
		var yp = canvas.height - (ev.clientY - rect.top);	//y==0 at canvas bottom edge
  
		// Convert to Canonical View Volume (CVV) coordinates too:
		var x = (xp - canvas.width/2)  / (canvas.width/2);			// normalize canvas to -1 <= x < +1,
		var y = (yp - canvas.height/2) / (canvas.height/2);
	
		var proj = rend.cam0.projectionMatrix()
		var view = rend.cam0.viewMatrix()
		var projView = proj.multiply(view)
		
		var inv = new Matrix4().setInverseOf(projView)
		
		var clickCoord = inv.multiplyVector4( new Vector4([x,y,0.8,1.0]) )
		var xdir = (clickCoord.elements[0]/ clickCoord.elements[3]) - rend.cam0.eye.x()
		var ydir = (clickCoord.elements[1]/ clickCoord.elements[3]) - rend.cam0.eye.y()
		var zdir = (clickCoord.elements[2]/ clickCoord.elements[3]) - rend.cam0.eye.z()
		
		this.addParticle({
			"PARTXPOS":rend.cam0.eye.x(),
			"PARTYPOS":rend.cam0.eye.y(),
			"PARTZPOS":rend.cam0.eye.z(),
			"PARTXVEL": xdir*3,
			"PARTYVEL": ydir*3,
			"PARTZVEL": zdir*3,
		})
	}
	this.solvers = {
	
	}
	this.sovler = null
	this.getForceVar = function(i,var_name){
		return this.forceBuffer[ (i * this.force_vars.FORCESTRIDE) + this.force_vars[var_name] ]
	}
	this.getWallVar = function(i,var_name){
		return this.wallBuffer[ (i * this.wall_vars.WALLSTRIDE) + this.wall_vars[var_name] ]
	}
	this.getParticleVar = function(i,var_name){
		return this.activeParticleBuffer[ (i * this.particle_vars.PARTICLESTRIDE) + this.particle_vars[var_name] ]
	}
	this.setParticleVar = function(i, var_name, value){
		this.activeParticleBuffer[ (i * this.particle_vars.PARTICLESTRIDE) + this.particle_vars[var_name] ] = value
	}
	this.applyAllForces = function(){
		//apply velocities
		for(var i = 0; i < this.numForces; i++){
		
			var force_type = this.getForceVar(i,"TYPE")
			switch(force_type){
				case 2://FGRAVE
					for(var p = 0; p < this.numParticles; p++){
						var yvel = this.getParticleVar(p, "PARTYVEL")
						this.setParticleVar(p,"PARTYVEL", yvel - 0.0025)
					}
			}
		}
		//move particles according to velocity
		for(var p = 0; p < this.numParticles; p++){
			var zvel = this.getParticleVar(p, "PARTZVEL")
			var xvel = this.getParticleVar(p, "PARTXVEL")
			var yvel = this.getParticleVar(p, "PARTYVEL")
			
			var zpos = this.getParticleVar(p, "PARTZPOS")
			var xpos = this.getParticleVar(p, "PARTXPOS")
			var ypos = this.getParticleVar(p, "PARTYPOS")
			
			this.setParticleVar(p,"PARTZPOS", zpos + zvel)
			this.setParticleVar(p,"PARTXPOS", xpos + xvel)
			this.setParticleVar(p,"PARTYPOS", ypos + yvel)
		}
	
	}
	this.applyAllWalls = function(){
		for(var i = 0; i < this.numWalls; i++){
		
			var wall_type = this.getWallVar(i,"TYPE")
			switch(wall_type){
				case 1://BOX IN
					for(var p = 0; p < this.numParticles; p++){
						var xpos = this.getParticleVar(p, "PARTXPOS")
						var ypos = this.getParticleVar(p, "PARTYPOS")
						var zpos = this.getParticleVar(p, "PARTZPOS")
						var xvel = this.getParticleVar(p, "PARTXVEL")
						var yvel = this.getParticleVar(p, "PARTYVEL")
						var zvel = this.getParticleVar(p, "PARTZVEL")
						
						var boxX = this.getWallVar(i,"WALLXPOS")
						var boxY = this.getWallVar(i,"WALLYPOS")
						var boxZ = this.getWallVar(i,"WALLZPOS")
						
						var rad = this.getWallVar(i,"RADIUS")
						
						//reverse x
						if(xpos > boxX + rad ){
							this.setParticleVar(p,"PARTXPOS", boxX + rad )
							this.setParticleVar(p,"PARTXVEL", xvel * -1)
						}
						if( xpos < boxX - rad){
							this.setParticleVar(p,"PARTXPOS", boxX - rad )
							this.setParticleVar(p,"PARTXVEL", xvel * -1)
						}
						
						//reverse y
						if(ypos > boxY + rad ){
							this.setParticleVar(p,"PARTYPOS", boxY + rad )
							this.setParticleVar(p,"PARTYVEL", yvel * -1)
						}
						if( ypos < boxY - rad){
							this.setParticleVar(p,"PARTYPOS", boxY - rad )
							this.setParticleVar(p,"PARTYVEL", yvel * -1)
						}
						
						//reverse z
						if(zpos > boxZ + rad ){
							this.setParticleVar(p,"PARTZPOS", boxZ + rad )
							this.setParticleVar(p,"PARTZVEL", zvel * -1)
						}
						if(zpos < boxZ - rad){
							this.setParticleVar(p,"PARTZPOS", boxZ - rad )
							this.setParticleVar(p,"PARTZVEL", zvel * -1)
						}
						
					}
				case 2://BOX OUT
					for(var p = 0; p < this.numParticles; p++){
						var yvel = this.getParticleVar(p, "PARTYVEL")
						this.setParticleVar(p,"PARTYVEL", yvel - 0.0025)
					}
				case 3://SPHERE
					for(var p = 0; p < this.numParticles; p++){
						var yvel = this.getParticleVar(p, "PARTYVEL")
						this.setParticleVar(p,"PARTYVEL", yvel - 0.0025)
					}
			}
		
		}
	
	}
	this.draw = function(){
		this.applyAllForces()
		this.applyAllWalls()
		
		gl.bindBuffer(gl.ARRAY_BUFFER, this.activeParticleBufferID);
		gl.bufferData(gl.ARRAY_BUFFER, this.activeParticleBuffer, gl.DYNAMIC_DRAW);
		//attributeID, size of vector, type, normalized?, stride, offset
		var stride = this.particle_vars.PARTICLESTRIDE * this.activeParticleBuffer.BYTES_PER_ELEMENT
		gl.vertexAttribPointer(a_PositionID,3,gl.FLOAT, false, stride,0)
		gl.drawArrays(gl.POINTS, 0, this.numParticles);
	}
	/*
	this.dotMaker = function(CPart *pDotDest, CPart *pSrc
	, CForcer *pF, CWall *pW)){
		
	}
	this.applyAllForces = function(CPart *pS, CForcer *pF);
	this.applyAllWalls = function(CPart *pS_now, CPart *pS_prev,  CWall *pWsrc);
	this.stateVecSwap = function(CPart **ppA, CPart **ppB);
	
	void stateVecSizer(int nuSize);// For each state vector, create a new array
	// (dyn. allocation) of particles.  Discard
	// any previous particles (if any) and if
	// successful, set partCount to 'nuSize'.
	// (NOTE: same size for all state-vectors).
	void stateVecWipe(void);        // Discard all existing memory allocated for
	// state vectors in this CPartSys.

	void stateVecDraw(CPart *pS);   // Draw state-vector pS usingOpenGL calls.

	// Math operators (BETTER: use operator overloading!)
	void stateVecZero(CPart *pS);                   // set state to zero
	void stateVecAssign(CPart *pDest, CPart *pSrc); // copy src to dest
	void stateVecAplusBtimesC(CPart *pDest, CPart *pA, CPart *pB, double scl);
	// dest = A + scl*B

	//-------Force-List Vector(s)----------------
	int forcerCount;                // # of forcer-making objects held in the
	// dyn. alloc'd list at pF0 (if needed, in
	// pF1, pFM, pF0dot,pF1dot,pFMdot as well).
	CForcer *pF0;                   // f0; forcer-vector-- dyn. alloc'd list of
	// all CURRENT force-making objects,
	// *pF0dot;                     //  and its time-derivative f0dot
	// (==NULL if none).
	/*
	// OPTIONAL: as needed,
	//      create these additional forcer-vectors to implement time-dependent-
	//      and particle-dependent (?and wall-dependent?) force-making objects.
	//  !!CAREFUL!!! Be sure to update forcerVecSizer(), forcerVecWipe(),
	//               CPartSys() and ~CPartSys() for the new forcer-vectors;
	//  NOTE: all forcer-vectors are the same size (CPartSys:: forcerCount).
	CForcer *pF1, pF1dot;           // f1; forcer-vector--dyn. alloc'd list of
									// all NEXT force-making objects, and its
									// time-derivative f1dot (==NULL if none)
	CForcer *pFM, *pFMdot;          // fM, fMdot; midpoint forcer-vector and its
									// time deriv. (see solver, midpoint method)

	void forcerVecSizer(int nuSize);// Change the size of each dyn.-alloc'd list
	// of force-applying objects (CForcer obj.).
	// Discard any previous forcers (if any),
	// and if successful, set forcerCount to
	// nuSize.(same size for all forcer-vectors)
	void forcerVecWipe(void);       // Discard all existing memory allocated
	// for forcer-vectors in this CPartSys.
	void forcerVecDraw(CForcer *pF, CPart *pS);
	// Draw forcer-vector pF using OpenGL calls;
	// (needs corresponding state-vector at pS
	// because force-applying springs get their
	// positions in space from the particles
	// they connect together).
	//-------Wall-Vectors(s)---------------
	int wallCount;                  //# of constraint-making objects (CWall obj)
	// held in the dyn. alloc'd list at pC0.
	CWall *pC0;                     // c0; constraint-vector--dyn. alloc'd list
	// of all CURRENT constraint-making objects,
	//CWall *pC0dot;                  // and its time-derivative c0dot
	// (==NULL if none).
	// OPTIONAL: as needed,
	//      create these additional wall-vectors to implement time-dependent-0
	//      and particle-dependent (?and forcer-dependent?) wall-making objects.
	// !!CAREFUL!! Be sure to update wallVecSizer(), wallVecWipe(), CPartSys()
	//      and ~CPartSys() for the new forcer-vectors.
	// NOTE: same size for all wall-vectors)
	void wallVecSizer(int nuSiz);   // For each limit-vector, create (by dyn.
	// allocation) an new array of constraints
	// (CLimit objects). Discard any prev.
	// constraints (if any), and if successful,
	// set limitCount to nuSiz.
	// (NOTE: same size for all limit-vectors).
	void wallVecWipe(void);         // Discard all existing memory allocated
	// for wall-vectors in this CPartSys.
	void wallVecDraw(CWall *pC);    // Draw the wall-vector pC with OpenGL calls
	
	*/

}

var utils =  {
	
	getShader : function(gl, elementId) {
		var shaderScript, theSource, currentChild, shader;

		var shaderScript = document.getElementById(elementId);
		var theSource = "";
		var currentChild = shaderScript.firstChild;

		while(currentChild) {
			if (currentChild.nodeType == currentChild.TEXT_NODE) {
				theSource += currentChild.textContent;
			}
			currentChild = currentChild.nextSibling;
		}
		
		if (shaderScript.type == "x-shader/x-fragment") {
			shader = gl.createShader(gl.FRAGMENT_SHADER);
		} else if (shaderScript.type == "x-shader/x-vertex") {
			shader = gl.createShader(gl.VERTEX_SHADER);
		} else {
			return null;
		}

		gl.shaderSource(shader, theSource);
		gl.compileShader(shader);  
		
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {  
			alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));  
			return null;  
		}
		
		return shader;
	},
	lastTime: 0,
	elapsedTime: function(sinceTime) {
		if (!lastTime)  lastTime = Date.now();
		return Date.now() - sinceTime;	
	},
};


var rend = new Renderer()
rend.start()



</script>
</body>
<body>
<button type="button" onclick="rend.partSys.addCharge(0,0,-2,5)">Add charge in middle</button>
<button type="button" onclick="rend.circleCamera = true">Circle Camera ON</button>
<button type="button" onclick="rend.circleCamera = false">Circle Camera OFF</button>
Camera Key Controls: (position) a,z,s,x,d,c (aim) arrow keys + f,v,
<canvas id="glcanvas" width="1024" height="768">
</canvas>




<script src="lib/webgl-utils.js"></script>
<script src="lib/webgl-debug.js"></script>
<script src="lib/cuon-utils.js"></script>
<script src="lib/cuon-matrix-quat.js"></script> 


<script id="fragmentShader" type="x-shader/x-fragment">
precision mediump float;

varying vec4 vColor;

void main(void) {
	gl_FragColor = vColor;
}
</script>

<script id="vertexShader" type="x-shader/x-vertex">
attribute vec3 a_Position;

uniform mat4 uViewMatrix;
uniform mat4 uProjMatrix;
uniform mat4 uModelMatrix;
uniform vec4 aColor;

varying vec4 vColor;

void main(void) {
	gl_Position = uProjMatrix * uViewMatrix * uModelMatrix * vec4(a_Position, 1.0);
	gl_PointSize = 10.0;
	vColor = aColor;
}
</script>


<script type="text/javascript">

//globals
var gl //context
var a_PositionID 
var a_ColorID 
var canvas //canvas element
var uModelMatrixID
var mouseDown = 0;
var MouseX
var MouseY

var Renderer = function(){
	 var Camera = function(){
		//look down the z negative axis
		this.eye = new Vector3([0,3,6])
		this.at = new Vector3([0,0,0])
		this.up = new Vector3([0,1,0])
		this.fovy  = 70
		this.aspect  = 1.0
		this.near = .01
		this.far  = 100
		
		this.pan = function(deg){
			this.at = new Matrix4().setRotate(-deg,this.up.x(),this.up.y(),this.up.z()).multiplyVector3(this.at)
		}
		this.tilt = function(deg){
			var crss = this.at.cross(this.up)//vec parrallel to both
			this.at = new Matrix4().setRotate(deg, crss.x(), crss.y(), crss.z()).multiplyVector3(this.at)
			this.up = new Matrix4().setRotate(deg, crss.x(), crss.y(), crss.z()).multiplyVector3(this.up)
		}
		this.roll = function(deg){
			this.up = new Matrix4().setRotate(deg,this.at.x(),this.at.y(),this.at.z()).multiplyVector3(this.up)
		}

		this.transX = function(unit){
			this.at.elements[0] = this.at.x() + unit
			this.eye.elements[0] = this.eye.x() + unit
		}
		this.transY = function(unit){
			this.at.elements[1] = this.at.y() + unit
			this.eye.elements[1] = this.eye.y() + unit
		}
		this.transZ = function(unit){
			this.at.elements[2] = this.at.z() + unit
			this.eye.elements[2] = this.eye.z() + unit
		}
		
		this.projectionMatrix = function(){
			return new Matrix4().setPerspective(this.fovy, this.aspect, this.near, this.far)
		}
		this.viewMatrix = function(){
			return new Matrix4().setLookAt(this.eye.x(), this.eye.y(), this.eye.z(), this.at.x(), this.at.y(), this.at.z(), this.up.x(), this.up.y(), this.up.z())
		}
		
		this.keyboardControl = function(ev){
			var speed = 2
			switch(ev.keyCode) {
				case 39://right arrow
					this.pan(speed);break
				case 37://left arrow
					this.pan(-speed);break
				case 38://up arrow
					this.tilt(speed);break
				case 40://down arrow
					this.tilt(-speed);break
				case 65://a
					this.transX(speed/40);break
				case 90://z
					this.transX(-speed/40);break
				case 83://s           
					this.transY(speed/40);break
				case 88://x           
					this.transY(-speed/40);break
				case 68://d           
					this.transZ(speed/40);break
				case 67://c           
					this.transZ(-speed/40);break
				case 70://f
					this.roll(speed);break
				case 86://v
					this.roll(-speed);break
			}
		
		}
		
	}
	this.cam0 = new Camera()
	this.circleCamera=false //circle the camera around center point
	this.uViewMatrixID
	this.uProjMatrixID 
	this.partSys
	this.ground_plane
	this.start = function(){
	
		//gl setup
		canvas = document.getElementById("glcanvas")
		canvas.width = window.innerWidth * .90
		canvas.height = window.innerHeight * .90
		gl = WebGLUtils.setupWebGL(canvas)

		gl.viewport(0,0,canvas.width,canvas.height)
		gl.clearColor(0.0, 0.0, 0.0, 1.0)                     
		gl.enable(gl.DEPTH_TEST)                              
		gl.depthFunc(gl.LEQUAL)  

		//compile shaders
		var fragmentShader = utils.getShader(gl, "fragmentShader");
		var vertexShader = utils.getShader(gl, "vertexShader");
		
		// Create the shader program
		shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);

		// If creating the shader program failed, alert

		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			alert("Unable to initialize the shader program.");
		}

		gl.useProgram(shaderProgram);
		
		//position attribute
		a_PositionID = gl.getAttribLocation(shaderProgram, 'a_Position')
		if(a_PositionID < 0) console.log('Failed to get the gfx storage location of a_Position')
		gl.enableVertexAttribArray(a_PositionID);
		
		
		//projection matrix location
		uProjMatrixID = gl.getUniformLocation(shaderProgram, 'uProjMatrix')
		if(uProjMatrixID < 0) console.log('Failed to get the gfx storage location of uProjMatrix')
		
		//view matrix location
		uViewMatrixID = gl.getUniformLocation(shaderProgram, 'uViewMatrix')
		if(uViewMatrixID < 0) console.log('Failed to get the gfx storage location of uViewMatrix')
		
		//model matrix location
		uModelMatrixID = gl.getUniformLocation(shaderProgram, 'uModelMatrix')
		if(uModelMatrixID < 0) console.log('Failed to get the gfx storage location of uModelMatrix')
		
		//model matrix location
		a_ColorID = gl.getUniformLocation(shaderProgram, 'aColor')
		
		//groundplane
		this.ground_plane = new GroundPlane(gl,"Y", 60, .2)
		this.ground_plane.init()
		
		//particle system
		this.partSys = new ParticleSystem(gl)
		this.partSys.initBuffers()
		
		//keyboard control
		window.addEventListener("keydown", this.cam0.keyboardControl.bind(this.cam0), false);
		
		document.body.onmousedown = function() { 
			  ++mouseDown;
		}
		
		document.body.onmouseup = function() {
			--mouseDown;
		}
		
		document.body.onmousemove = function(ev) {
				var rect = ev.target.getBoundingClientRect();	    // get canvas corners in pixels
				MouseX = ev.clientX - rect.left;					//x==0 at canvas left edge
				MouseY = canvas.height - (ev.clientY - rect.top);	//y==0 at canvas bottom edge
		}
		
		
		//add gravity
		this.partSys.addGravity()
		this.partSys.addBoxIn(0,6,0,6)
		this.partSys.addBoxOut(0,2,-3,1)
		
		window.requestAnimationFrame(this.draw.bind(this));
		
	}
	this.draw = function(){
		gl.clear(gl.COLOR_BUFFER_BIT)
		
		if(this.circleCamera){
			this.cam0.eye = new Matrix4().setRotate(0.1, 0, 1, 0).multiplyVector3(this.cam0.eye)
		}
			
		
		//set camera placement
		gl.uniformMatrix4fv(uProjMatrixID, false, this.cam0.projectionMatrix().elements)
		gl.uniformMatrix4fv(uViewMatrixID, false, this.cam0.viewMatrix().elements)
		
		//model matrix is used by the models - set to identity for now
		gl.uniformMatrix4fv(uModelMatrixID, false, new Matrix4().elements)
		
		gl.uniform4fv(a_ColorID, new Float32Array([1,1,1,1]))
		
		this.ground_plane.draw()
		this.partSys.draw()
		
		window.requestAnimationFrame(this.draw.bind(this));
	}

}


//A ground plane is "renderable", meaning it takes gl context as input and provides a draw function
//axis == "X" "Y" or "Z" meaning x==0 y==0 or z==0
var GroundPlane = function(glContext, axis, num_lines, spacing){
	this.gl = glContext
	this.lineLength = 13
	this.vertexBuffer = new Float32Array(num_lines * 2 * 3 * 2 * 2)//2pts per line, 3 floats per point, 1 line horizontal, 1 vertical
	this.vertexBufferID
	this.init = function(){
		this.vertexBufferID = gl.createBuffer()
		if (!this.vertexBufferID) console.log('Failed to create tgorund plane vertex buffer');
		
		var start = -( spacing * (num_lines/2) )//the position the first line starts at
		var end = start * -1
		var i = 0
		for(var pos=start; pos <= (end*2); pos=pos+spacing){
			//extend down z
			this.vertexBuffer[i] = pos //X
			this.vertexBuffer[i+1] = 0 //Y
			this.vertexBuffer[i+2] = -(this.lineLength/2) //Z
			                   
			this.vertexBuffer[i+3] = pos //X
			this.vertexBuffer[i+4] = 0 //Y
			this.vertexBuffer[i+5] = (this.lineLength/2) //Z
			
			//extend down x
			this.vertexBuffer[i+6] = -(this.lineLength/2) //X
			this.vertexBuffer[i+7] = 0 //Y
			this.vertexBuffer[i+8] = pos //Z
			                    
			this.vertexBuffer[i+9] = (this.lineLength/2) //X
			this.vertexBuffer[i+10] = 0 //Y
			this.vertexBuffer[i+11] = pos //Z
			
			i = i + 12
		}
		console.log(this.vertexBuffer)
		
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBufferID);
		gl.bufferData(gl.ARRAY_BUFFER, this.vertexBuffer, gl.STATIC_DRAW);
		
		
	}
	this.draw = function(){
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBufferID);
		
		//attributeID, size of vector, type, normalized?, stride, offset
		gl.vertexAttribPointer(a_PositionID,3,gl.FLOAT, false, 0,0)
		
		gl.uniform4fv(a_ColorID, new Float32Array([1,0,1,1]))
		gl.drawArrays(gl.LINES, 0, num_lines * 4);
		gl.uniform4fv(a_ColorID, new Float32Array([1,1,1,1]))
	}
}

//drawable
var Box = function(x,y,z,len){
		this.vertexID = gl.createBuffer()
		this.indexID = gl.createBuffer()
		this.x = x
		this.y = y 
		this.z = z
		this.size = len
        this.vertices = [
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,

            // Back face
            -1.0, -1.0, -1.0,
            -1.0,  1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0, -1.0, -1.0,

            // Top face
            -1.0,  1.0, -1.0,
            -1.0,  1.0,  1.0,
             1.0,  1.0,  1.0,
             1.0,  1.0, -1.0,

            // Bottom face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,

            // Right face
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
             1.0,  1.0,  1.0,
             1.0, -1.0,  1.0,

            // Left face
			-1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,

        ]
        this.cubeVertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
		this.draw = function(){
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexID);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
			
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexID);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.cubeVertexIndices), gl.STATIC_DRAW);
			
			gl.vertexAttribPointer(a_PositionID,3,gl.FLOAT, false, 0,0)
			
			//set model matrix
			var scale = new Matrix4().setScale(this.size, this.size, this.size)
			var model = new Matrix4().setTranslate(this.x, this.y, this.z).multiply( scale ) 
			gl.uniformMatrix4fv(uModelMatrixID, false, model.elements)
			
			gl.uniform4fv(a_ColorID, new Float32Array([0,0.8,0.2,1]))
			gl.drawElements(gl.TRIANGLES, 24, gl.UNSIGNED_SHORT, 0);
			gl.uniform4fv(a_ColorID, new Float32Array([1,1,1,1]))
			
			//set back to identity
			gl.uniformMatrix4fv(uModelMatrixID, false, new Matrix4().elements)
		}
}

//A particle system is "renderable", meaning it takes gl context as input and provides a draw function
var ParticleSystem = function(glContext){
	this.gl = glContext
	
	this.particleBufferSize = 100000 //starting size of buffer
	this.numParticles = 0 //0 particles to start out
	this.particleBuffers = {//all buffers start as null
		ps0      : null,
		ps0dot   : null,
		ps1      : null,
		ps1dot   : null,
		psMid    : null,
		psMidDot : null,
	}
	this.ps0BufferID
	this.ps1BufferID
	
	this.activeParticleBuffer
	this.activeDotBuffer
	this.activeParticleBufferID
	
	this.nonActiveParticleBuffer
	this.nonActiveDotBuffer
	this.nonActiveParticleBufferID
	
	this.forceBufferSize = 100 //starting size of buffer
	this.numForces = 0 //0 forces to start out
	this.forceBuffer 
	
	this.wallBufferSize = 30 //starting size of buffer
	this.numWalls = 0 //0 walls to start out
	this.wallBuffer
	
	//this is a list of objects in the scene that have a draw call
	this.drawAbles = []
	
	//an enumeration
	this.particle_vars = {
		PARTXPOS     : 0,  //  position    
		PARTYPOS     : 1,
		PARTZPOS     : 2,
		PARTXVEL     : 3, //  velocity    
		PARTYVEL     : 4,
		PARTZVEL     : 5,
		PARTXFTOT   : 6,  // force accumulator:'ApplyForces()' fcn clears
		PARTYFTOT   : 7,  // to zero, then adds each force to each particle.
		PARTZFTOT   : 8,        
		PARTR        : 9,  // color : red,green,blue
		PARTG        :10,  
		PARTB        :11,
		PARTMASS     :12,  // mass   
		PARTDIAM 	  :13,	// on-screen diameter (in pixels)
		PARTRENDMODE :14,	// on-screen appearance (square, round, or soft-round)
		PARTAGE      :15,  // # of frame-times since creation/initialization
		PARTCHARGE   :16,  // for electrostatic repulsion/attraction
		PARTMASSVEL :17,  // time-rate-of-change of mass.
		PARTMASSFTOT:18,  // force-accumulator for mass-change
		
		PARTICLESTRIDE:19,  // Size of array in CPart uses to store its values.
	}
	this.affected_particle_set = {
		ALL:0,
		PARTINDEX1:1,
		BOTH12:2,
	}
	this.wall_vars= {
		wall_types: {
			WTYPEDEAD       :0,   // not in use
			WTYPEBOXIN		 :1,
			WTYPEBOXOUT     :2,
			WTYPESPHERE     :3,  // solid sphere centered at particle with index e0;
			// no other particles allowed closer than 'radmin'
			// to the e0 particle.
			// (NOTE: e0 is a state-vector index: pS0[e0] )
			
			WTYPESTICK      :4,  // Connects 2 particles with fixed-length separation
			// between particles whose indices are held in e0,e1
			// (e.g. particles at pS0[e0] and pS0[e1] )
			WTYPEPULLEY     :5,  // Keep constant sum-of-distances for 3 particles
			// A,B,Pivot:  ||A-Pivot||+||B-Pivot|| = dmax.
			WTYPEANCHOR     :6,  // Lock one particle at location xpos,ypos,zpos
		},
		TYPE:0, //one of the "wall_types" from above
		KBOUNCY:1,//how bouncy is this wall
		WALLXPOS:2,
		WALLYPOS:3,
		WALLZPOS:4,
		RADIUS:5,
		AFFECTEDPARTICLES:6,//instance of "affected particle set"
		PARTINDEX1:7,		 //index of particle affected by constraint
		PARTINDEX2:8,
		
		WALLSTRIDE:9, //stride of a wall object
	}
	this.force_vars = {
		force_types: {
			FNONE      :0,       // Non-existent force: ignore this CForcer object
			FMOUSE     :1,       // Spring-like connection to the mouse cursor; lets
			// you 'grab' and 'wiggle' one particle(or several).
			FGRAVE    :2,       // Earth-gravity: pulls all particles 'downward'.
			FGRAVP    :3,       // Planetary-gravity; particle-pair (e0,e1) attract
			// each other with force== grav* mass0*mass1/ dist^2
			FWIND      :4,       // Blowing-wind-like force-field;fcn of 3D position
			FBUBBLE    :5,       // Constant inward force towards centerpoint if
			// particle is > max_radius away from centerpoint.
			FDRAG      :6,       // Viscous drag -- proportional to neg. velocity.
			FSPRING    :7,       // ties together 2 particles; distance sets force
			FSPRINGSET :8,       // a big collection of identical springs; lets you
			// make cloth & rubbery shapes as one force-making
			// object, instead of many many F_SPRING objects.
			FCHARGE    :9,       // attract/repel by charge and inverse distance;
			// applies to all charged particles.
		},
		TYPE:0,//one of the force_types from above
		POSX:1,
		POSY:2,
		POSZ:3,
		DIRX:4,
		DIRY:5,
		DIRZ:6,
		STRENGTH:7,
		RESTSTRENGTH:8,// Less than this treat as strength zero
		AFFECTEDPARTICLES:9,//type "affected particle set"
		PARTINDEX1:10,
		PARTINDEX2:11,
		
		FORCESTRIDE:12,
	}
	this.initBuffers = function(){
		this.forceBuffer = new Float32Array(this.forceBufferSize * this.force_vars.FORCESTRIDE)
		this.wallBuffer = new Float32Array(this.wallBufferSize * this.wall_vars.WALLSTRIDE)
	
		for(key in this.particleBuffers){
			this.particleBuffers[key] = new Float32Array(this.particleBufferSize * this.particle_vars.PARTICLESTRIDE);
		}
		
		this.ps0BufferID = gl.createBuffer()
		this.ps1BufferID = gl.createBuffer()
		
		this.activeParticleBuffer = this.particleBuffers.ps0
		this.activeDotBuffer = this.particleBuffers.ps0dot
		this.activeParticleBufferID = this.ps0BufferID
		
		this.nonActiveParticleBuffer = this.particleBuffers.ps1
		this.nonActiveDotBuffer = this.particleBuffers.ps1dot
		this.nonActiveParticleBufferID = this.ps1BufferID
		
		gl.bindBuffer(gl.ARRAY_BUFFER, this.ps0BufferID);
		gl.bufferData(gl.ARRAY_BUFFER, this.particleBuffers.ps0, gl.DYNAMIC_DRAW);
	}
	//example addForce({TYPE:F_GRAV_E, AFECTED_PARTICLES: ALL}
	this.addForce = function( array_literal ){
		this.numForces += 1
		if(this.numForces > this.forceBufferSize){
			alert("cannot add more particles. need to implement buffer resizing")
			return
		}
		
		//current force index
		var i = (this.numForces-1) * this.force_vars.FORCESTRIDE
		
		//iterate through array_literal and add to buffer
		for(key in array_literal){
		
			//get value
			var value = array_literal[key]
			if(key == "TYPE")//special case since type must be converted to int
				value = this.force_vars.force_types[value]
			if(key == "AFFECTEDPARTICLES")
				value = this.affected_particle_set[value]
		
			//set value
			var var_offset = this.force_vars[key]
			this.forceBuffer[i + var_offset] =  value
		}
			
	
	}
	//example addForce({TYPE:F_GRAV_E, AFECTED_PARTICLES: ALL}
	this.addWall = function( array_literal ){
		this.numWalls += 1
		if(this.numWalls > this.wallBufferSize){
			alert("cannot add more walls. need to implement buffer resizing")
			return
		}
		
		//current force index
		var i = (this.numWalls-1) * this.wall_vars.WALLSTRIDE
		
		//iterate through array_literal and add to buffer
		for(key in array_literal){
		
			//get value
			var value = array_literal[key]
			if(key == "TYPE")//special case since type must be converted to int
				value = this.wall_vars.wall_types[value]
			if(key == "AFFECTEDPARTICLES")
				value = this.affected_particle_set[value]
		
			//set value
			var var_offset = this.wall_vars[key]
			this.wallBuffer[i + var_offset] =  value
		}
	}
	this.addParticle = function( array_literal ){
		this.numParticles += 1
		if(this.numParticles >= this.particlesBufferSize){
			alert("cannot add more Particles. need to implement buffer resizing")
			return
		}
		
		//current force index
		var i = (this.numParticles-1) * this.particle_vars.PARTICLESTRIDE
		
		//iterate through array_literal and add to buffer
		for(key in array_literal){
			//set value
			var var_offset = this.particle_vars[key]
			this.activeParticleBuffer[i + var_offset] =  array_literal[key]
		}
	}
	this.addBoxIn= function(x,y,z,length){
		this.addWall({
			'TYPE':'WTYPEBOXIN',
			'KBOUNCY':0.8,
			'WALLXPOS':x,
			'WALLYPOS':y,
			'WALLZPOS':z,
			'RADIUS':length,
			'AFFECTEDPARTICLES':"ALL"
		})
	}
	this.addBoxOut= function(x,y,z,length){
	
		this.drawAbles.push(new Box(x,y,z,length))
	
		this.addWall({
			TYPE:"WTYPEBOXOUT",
			KBOUNCY:0.8,
			WALLXPOS:x,
			WALLYPOS:y,
			WALLZPOS:z,
			RADIUS:length,
			AFFECTEDPARTICLES:"ALL"
		})
	}
	this.addSphere = function(x,y,x,radius){
		this.addWall({
			TYPE:"WTYPESPHERE",
			KBOUNCY:0.5,
			WALLXPOS:x,
			WALLYPOS:y,
			WALLZPOS:z,
			RADIUS:radius,
			AFFECTED_PARTICLES:"ALL"
		})
	
	}
	this.addGravity = function(strength){
		this.addForce({
			TYPE:"FGRAVE", 
			AFECTED_PARTICLES: "ALL",
		})
	}
	this.addCharge = function(x,y,z,strength){
	
		this.addForce({
			TYPE:"FCHARGE",
			STRENGTH:strength,
			POSX:x,
			POSY:y,
			POSZ:z,
			AFECTED_PARTICLES: "ALL",
		})
	
	}
	this.addFlock = function(x,y,z){
	
	}
		if(mouseDown)
			this.shootParticle(ev)
	this.shootParticle = function(xp,yp){
  
		// Convert to Canonical View Volume (CVV) coordinates too:
		var x = (xp - canvas.width/2)  / (canvas.width/2);			// normalize canvas to -1 <= x < +1,
		var y = (yp - canvas.height/2) / (canvas.height/2);
	
		var proj = rend.cam0.projectionMatrix()
		var view = rend.cam0.viewMatrix()
		var projView = proj.multiply(view)
		
		var inv = new Matrix4().setInverseOf(projView)
		
		var clickCoord = inv.multiplyVector4( new Vector4([x,y,0.8,1.0]) )
		var xdir = (clickCoord.elements[0]/ clickCoord.elements[3]) - rend.cam0.eye.x()
		var ydir = (clickCoord.elements[1]/ clickCoord.elements[3]) - rend.cam0.eye.y()
		var zdir = (clickCoord.elements[2]/ clickCoord.elements[3]) - rend.cam0.eye.z()
		
		this.addParticle({
			"PARTXPOS":rend.cam0.eye.x(),
			"PARTYPOS":rend.cam0.eye.y(),
			"PARTZPOS":rend.cam0.eye.z(),
			"PARTXVEL": xdir*3,
			"PARTYVEL": ydir*3,
			"PARTZVEL": zdir*3,
			"PARTMASS": 1,
		})
	}
	this.getForceVar = function(i,var_name){
		return this.forceBuffer[ (i * this.force_vars.FORCESTRIDE) + this.force_vars[var_name] ]
	}
	this.getWallVar = function(i,var_name){
		return this.wallBuffer[ (i * this.wall_vars.WALLSTRIDE) + this.wall_vars[var_name] ]
	}
	this.getParticleVar = function(i, buffer,var_name){
		return buffer[ (i * this.particle_vars.PARTICLESTRIDE) + this.particle_vars[var_name] ]
	}
	this.setParticleVar = function(i, buffer, var_name, value){
		buffer[ (i * this.particle_vars.PARTICLESTRIDE) + this.particle_vars[var_name] ] = value
	}
	this.applyAllForces = function(buffer, timestep){
		//first clear all particles FTOT to ZERO
		for(var p = 0; p < this.numParticles; p++){
			this.setParticleVar(p,buffer,"PARTXFTOT", 0)
			this.setParticleVar(p,buffer,"PARTYFTOT", 0)
			this.setParticleVar(p,buffer,"PARTZFTOT", 0)
		}
		//now accumulate forces
		for(var i = 0; i < this.numForces; i++){
		
			var force_type = this.getForceVar(i,"TYPE")
			switch(force_type){
				case 2://FGRAVE
					for(var p = 0; p < this.numParticles; p++){
						var ytot = this.getParticleVar(p, buffer, "PARTYFTOT")
						this.setParticleVar(p, buffer, "PARTYFTOT", ytot - (0.06 * timestep))
					}
					break
				case 9://charge
					for(var p = 0; p < this.numParticles; p++){
						//charge pos
						var chargeX = this.getForceVar(i,"POSX")
						var chargeY = this.getForceVar(i,"POSY")
						var chargeZ = this.getForceVar(i,"POSZ")
						//part pos
						var x = this.getParticleVar(p,buffer, "PARTXPOS")
						var y = this.getParticleVar(p,buffer, "PARTYPOS")
						var z = this.getParticleVar(p,buffer, "PARTZPOS")
						
						//calc force
						var dist = utils.distanceBetweenPoints(x,y,z,chargeX,chargeY,chargeZ)
						var force = 0.08 / (dist + .000001)
						var direction = new Vector3([x - chargeX, y - chargeY, z - chargeZ]).normalize()
						
						var xForce = force * direction.x()
						var yForce = force * direction.y()
						var zForce = force * direction.z()
						
						
						//get current forces
						var xftot = this.getParticleVar(p, buffer, "PARTXFTOT")
						var yftot = this.getParticleVar(p, buffer, "PARTYFTOT")
						var zftot = this.getParticleVar(p, buffer, "PARTZFTOT")
						//set forces
						this.setParticleVar(p,buffer, "PARTXFTOT", xftot + xForce)
						this.setParticleVar(p,buffer, "PARTYFTOT", yftot + yForce)
						this.setParticleVar(p,buffer, "PARTZFTOT", zftot + zForce)
					}
					break
			}
		}
	
	}
	this.applyAllWalls = function(buffer){
		for(var i = 0; i < this.numWalls; i++){
		
			var wall_type = this.getWallVar(i,"TYPE")
			switch(wall_type){
				case 1://BOX IN
					for(var p = 0; p < this.numParticles; p++){
						var xpos = this.getParticleVar(p,buffer, "PARTXPOS")
						var ypos = this.getParticleVar(p,buffer, "PARTYPOS")
						var zpos = this.getParticleVar(p,buffer, "PARTZPOS")
						var xvel = this.getParticleVar(p,buffer, "PARTXVEL")
						var yvel = this.getParticleVar(p,buffer, "PARTYVEL")
						var zvel = this.getParticleVar(p,buffer, "PARTZVEL")
						
						var boxX = this.getWallVar(i,"WALLXPOS")
						var boxY = this.getWallVar(i,"WALLYPOS")
						var boxZ = this.getWallVar(i,"WALLZPOS")
						
						var rad = this.getWallVar(i,"RADIUS")
						
						var kbounce = this.getWallVar(i,"KBOUNCY")
						
						//reverse x
						if(xpos > boxX + rad ){
							this.setParticleVar(p,buffer,"PARTXPOS", boxX + rad )
							this.setParticleVar(p,buffer,"PARTXVEL", xvel * -1 * kbounce)
						}
						if( xpos < boxX - rad){
							this.setParticleVar(p,buffer,"PARTXPOS", boxX - rad )
							this.setParticleVar(p,buffer,"PARTXVEL", xvel * -1 * kbounce)
						}
						
						//reverse y
						if(ypos > boxY + rad ){
							this.setParticleVar(p,buffer,"PARTYPOS", boxY + rad )
							this.setParticleVar(p,buffer,"PARTYVEL", yvel * -1 * kbounce)
						}
						if( ypos < boxY - rad){
							this.setParticleVar(p,buffer,"PARTYPOS", boxY - rad )
							this.setParticleVar(p,buffer,"PARTYVEL", yvel * -1 * kbounce)
						}
						
						//reverse z
						if(zpos > boxZ + rad ){
							this.setParticleVar(p,buffer,"PARTZPOS", boxZ + rad )
							this.setParticleVar(p,buffer,"PARTZVEL", zvel * -1* kbounce)
						}
						if(zpos < boxZ - rad){
							this.setParticleVar(p,buffer,"PARTZPOS", boxZ - rad )
							this.setParticleVar(p,buffer,"PARTZVEL", zvel * -1* kbounce)
						}
						
					}
					break;
				case 2://BOX OUT
					for(var p = 0; p < this.numParticles; p++){
						var xpos = this.getParticleVar(p, buffer, "PARTXPOS")
						var ypos = this.getParticleVar(p, buffer, "PARTYPOS")
						var zpos = this.getParticleVar(p, buffer, "PARTZPOS")
						var xvel = this.getParticleVar(p, buffer, "PARTXVEL")
						var yvel = this.getParticleVar(p, buffer, "PARTYVEL")
						var zvel = this.getParticleVar(p, buffer, "PARTZVEL")
						
						var boxX = this.getWallVar(i,"WALLXPOS")
						var boxY = this.getWallVar(i,"WALLYPOS")
						var boxZ = this.getWallVar(i,"WALLZPOS")
						
						var rad = this.getWallVar(i,"RADIUS")
						var kbounce = this.getWallVar(i,"KBOUNCY")
						
						var insideBox = false
						if( zpos < (boxZ + rad) && 
							xpos < (boxX + rad) &&
							xpos > (boxX - rad) &&
							ypos < (boxY + rad) &&
							ypos > (boxY - rad) &&
							
							zpos > (boxZ - rad)){
							insideBox = true
							
							 this.setParticleVar(p,buffer,"PARTZPOS", boxZ + rad )
							 this.setParticleVar(p,buffer,"PARTZVEL", zvel * -1* kbounce)
							}
						
						//reverse x


						
					}
				case 3://SPHERE
					for(var p = 0; p < this.numParticles; p++){
						var yvel = this.getParticleVar(p, "PARTYVEL")
						this.setParticleVar(p,"PARTYVEL", yvel - 0.0025)
					}
			}
		
		}
	
	}
	this.dotMaker = function(part_buffer, dot_buffer){
		for(var i = 0; i < this.numParticles; i++){
			//copy over velocities
			var xvel = this.getParticleVar(i,part_buffer,"PARTXVEL")
			var yvel = this.getParticleVar(i,part_buffer,"PARTYVEL")
			var zvel = this.getParticleVar(i,part_buffer,"PARTZVEL")
			this.setParticleVar(i,dot_buffer,"PARTXPOS", xvel)
			this.setParticleVar(i,dot_buffer,"PARTYPOS", yvel)
			this.setParticleVar(i,dot_buffer,"PARTZPOS", zvel)
			
			//compute and set velocities
			var mass = this.getParticleVar(i,part_buffer,"PARTMASS")
			var ftotx = this.getParticleVar(i,part_buffer,"PARTXFTOT")
			var ftoty = this.getParticleVar(i,part_buffer,"PARTYFTOT")
			var ftotz = this.getParticleVar(i,part_buffer,"PARTZFTOT")
			var accx = ftotx / mass
			var accy = ftoty / mass
			var accz = ftotz / mass
			
			this.setParticleVar(i,dot_buffer,"PARTXVEL", accx)
			this.setParticleVar(i,dot_buffer,"PARTYVEL", accy)
			this.setParticleVar(i,dot_buffer,"PARTZVEL", accz)
	
		}
	
	}
	this.solvers = {
			//s1 = s0 + h*s0dot	
			"explicit_euler": function(non_active_part_buffer, part_buffer, dot_buffer , timestep){
					for(var i = 0; i < this.numParticles; i++){
					
						//part
						var partx = this.getParticleVar(i,part_buffer, "PARTXPOS")
						var party = this.getParticleVar(i,part_buffer, "PARTYPOS")
						var partz = this.getParticleVar(i,part_buffer, "PARTZPOS")
						
						var partxvel = this.getParticleVar(i,part_buffer, "PARTXVEL")
						var partyvel = this.getParticleVar(i,part_buffer, "PARTYVEL")
						var partzvel = this.getParticleVar(i,part_buffer, "PARTZVEL")
						
						//dot
						var dotx = this.getParticleVar(i,dot_buffer, "PARTXPOS")
						var doty = this.getParticleVar(i,dot_buffer, "PARTYPOS")
						var dotz = this.getParticleVar(i,dot_buffer, "PARTZPOS")
						
						var dotxvel = this.getParticleVar(i,dot_buffer, "PARTXVEL")
						var dotyvel = this.getParticleVar(i,dot_buffer, "PARTYVEL")
						var dotzvel = this.getParticleVar(i,dot_buffer, "PARTZVEL")
						
						//add
						this.setParticleVar(i,part_buffer,"PARTXPOS", partx + (dotx * timestep))
						this.setParticleVar(i,part_buffer,"PARTYPOS", party + (doty * timestep))
						this.setParticleVar(i,part_buffer,"PARTZPOS", partz + (dotz * timestep))
			
						this.setParticleVar(i,part_buffer,"PARTXVEL", partxvel + (dotxvel * timestep))
						this.setParticleVar(i,part_buffer,"PARTYVEL", partyvel + (dotyvel * timestep))
						this.setParticleVar(i,part_buffer,"PARTZVEL", partzvel + (dotzvel * timestep))
						
					}
			},
		
		}
	this.solve
	this.swapBuffers = function(){
	
		var temp	 = this.activeParticleBuffer
		var tempdot  = this.activeDotBuffer
		var tempID	 = this.activeParticleBufferID
	
		this.activeParticleBuffer = this.nonActiveParticleBuffer
		this.activeDotBuffer = this.nonActiveDotBuffer
		this.activeParticleBufferID = this.nonActiveParticleBufferID
		
		this.nonActiveParticleBuffer = temp
		this.nonActiveDotBuffer = tempdot
		this.nonActiveParticleBufferID = tempID
	
	}
	this.draw = function(timestep){
		var timestep = 1/3 //constant timestep for now
		
		if(mouseDown)
			this.shootParticle(MouseX,MouseY)
	
		//apply all force
		this.applyAllForces(this.activeParticleBuffer, timestep)
	
		//call dot maker on active particle buffer
		this.dotMaker(this.activeParticleBuffer, this.activeDotBuffer)
	
	
		//render active Particle buffer
		gl.bindBuffer(gl.ARRAY_BUFFER, this.activeParticleBufferID);
		gl.bufferData(gl.ARRAY_BUFFER, this.activeParticleBuffer, gl.DYNAMIC_DRAW);
		//attributeID, size of vector, type, normalized?, stride, offset
		var stride = this.particle_vars.PARTICLESTRIDE * this.activeParticleBuffer.BYTES_PER_ELEMENT
		gl.vertexAttribPointer(a_PositionID,3,gl.FLOAT, false, stride,0)
		gl.drawArrays(gl.POINTS, 0, this.numParticles);
		
		
		//solver - find non-active s1 from s0 and s0dot
		this.solve = this.solvers["explicit_euler"]
		this.solve(this.nonActiveParticleBuffer, this.activeParticleBuffer, this.activeDotBuffer,timestep)

		//apply constraints
		this.applyAllWalls(this.activeParticleBuffer)
		
		//swap
		//this.swapBuffers()
		
		//draw other things
		for(i in this.drawAbles)
			this.drawAbles[i].draw()
		
	}


}

var utils =  {
	distanceBetweenPoints : function(x1,y1,z1,x2,y2,z2){
		var sqrd = Math.pow(x1-x2,2) + Math.pow(y1-y2,2) + Math.pow(z1-z2,2)
		return Math.sqrt(sqrd)
	
	},
	getShader : function(gl, elementId) {
		var shaderScript, theSource, currentChild, shader;

		var shaderScript = document.getElementById(elementId);
		var theSource = "";
		var currentChild = shaderScript.firstChild;

		while(currentChild) {
			if (currentChild.nodeType == currentChild.TEXT_NODE) {
				theSource += currentChild.textContent;
			}
			currentChild = currentChild.nextSibling;
		}
		
		if (shaderScript.type == "x-shader/x-fragment") {
			shader = gl.createShader(gl.FRAGMENT_SHADER);
		} else if (shaderScript.type == "x-shader/x-vertex") {
			shader = gl.createShader(gl.VERTEX_SHADER);
		} else {
			return null;
		}

		gl.shaderSource(shader, theSource);
		gl.compileShader(shader);  
		
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {  
			alert("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));  
			return null;  
		}
		
		return shader;
	},
	lastTime: 0,
	elapsedTime: function(sinceTime) {
		if (!lastTime)  lastTime = Date.now();
		return Date.now() - sinceTime;	
	},
};


var rend = new Renderer()
rend.start()



</script>
</body>